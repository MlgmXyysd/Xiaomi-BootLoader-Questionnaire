{
    "latest": {
        "date": "2024-01-04",
        "problems": [
            {
                "id": 1,
                "index": 1,
                "random_options": false,
                "options": [
                    1,
                    2,
                    17,
                    16,
                    5,
                    18
                ]
            },
            {
                "id": 49,
                "index": 2,
                "random_options": false,
                "options": [
                    6,
                    7,
                    3,
                    4,
                    5
                ]
            },
            {
                "id": 52,
                "index": 3,
                "random_options": false,
                "options": [
                    1,
                    2,
                    3,
                    4,
                    5
                ]
            },
            {
                "id": 43,
                "index": 4,
                "random_options": false,
                "options": [
                    1,
                    2,
                    3,
                    4
                ]
            },
            {
                "id": 42,
                "index": 5,
                "random_options": true,
                "options": [
                    56,
                    55,
                    54,
                    16,
                    19
                ]
            },
            {
                "id": 63,
                "index": 6,
                "random_options": true,
                "options": [
                    2,
                    1
                ]
            },
            {
                "id": 42,
                "index": 7,
                "random_options": true,
                "options": [
                    57,
                    58,
                    59,
                    60,
                    61
                ]
            },
            {
                "id": 61,
                "index": 8,
                "random_options": true,
                "options": [
                    1,
                    2
                ]
            },
            {
                "id": 40,
                "index": 9,
                "random_options": true,
                "options": [
                    2,
                    4,
                    1,
                    3
                ]
            },
            {
                "id": 42,
                "index": 10,
                "random_options": true,
                "options": [
                    62,
                    63,
                    64,
                    51,
                    65
                ]
            },
            {
                "id": 18,
                "index": 11,
                "random_options": true,
                "options": [
                    5,
                    7,
                    8,
                    6
                ]
            },
            {
                "id": 42,
                "index": 12,
                "random_options": true,
                "options": [
                    66,
                    28,
                    67,
                    2,
                    68
                ]
            },
            {
                "id": 51,
                "index": 13,
                "random_options": true,
                "options": [
                    53,
                    36,
                    38,
                    35,
                    11
                ]
            },
            {
                "id": 62,
                "index": 14,
                "random_options": true,
                "options": [
                    2,
                    1
                ]
            },
            {
                "id": 42,
                "index": 15,
                "random_options": true,
                "options": [
                    69,
                    70,
                    71,
                    42,
                    72
                ]
            },
            {
                "id": 64,
                "index": 16,
                "random_options": false,
                "options": []
            },
            {
                "id": 42,
                "index": 17,
                "random_options": true,
                "options": [
                    73,
                    14,
                    74,
                    48,
                    75
                ]
            },
            {
                "id": 38,
                "index": 18,
                "random_options": true,
                "options": [
                    3,
                    2,
                    1,
                    4
                ]
            },
            {
                "id": 47,
                "index": 19,
                "random_options": true,
                "options": [
                    4,
                    3,
                    2,
                    5,
                    1
                ]
            },
            {
                "id": 42,
                "index": 20,
                "random_options": true,
                "options": [
                    76,
                    77,
                    78,
                    41,
                    79
                ]
            },
            {
                "id": 45,
                "index": 21,
                "random_options": true,
                "options": [
                    9,
                    10,
                    11,
                    2,
                    12
                ]
            }
        ]
    },
    "problems": [
        {
            "id": 1,
            "content": "以下关于《小米账号使用协议》和《BL解锁申请资格答题测试》的相关要求，说法正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "填空题务必不要复制粘贴其他网站的答案，答案雷同或相似度高，将视为无效问卷，无法获得分数",
                    "correct": true,
                    "explanation": "根据问卷填空题页面提示，如出现使用AI生成、复制粘贴、雷同试卷等情况，将视为无效作答，无法通过审核。"
                },
                {
                    "id": 2,
                    "content": "如果小米发现您并非该账号初始申请注册人，小米有权在未经通知的情况下终止您使用该账号",
                    "correct": true,
                    "explanation": "根据《小米账号使用协议》，任何情况下，您都无权使用由他人注册的账号。"
                },
                {
                    "id": 3,
                    "content": "当您获得BL解锁资格后，通过其他途径参与本答题测试，会根据行为严重程度，面临取消资格、账号终止使用等处罚",
                    "correct": true,
                    "explanation": "根据《BL解锁申请资格答题测试》的相关要求，您只能通过「小米社区」APP 参与答题。"
                },
                {
                    "id": 4,
                    "content": "当您小米社区等级未达到5段及以上时，通过其他途径参与本答题测试，会根据行为严重程度，面临账号终止使用等处罚",
                    "correct": true,
                    "explanation": "本选项的表述是对上一选项的补充。"
                }
            ]
        },
        {
            "id": 2,
            "content": "关于BL解锁说法正确的是",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "未答题或未达到答题分数线时，每7天可重新参与一次答题",
                    "correct": true,
                    "explanation": "根据答题后的分数页面提示，每 7 天可以重复参与一次答题。"
                },
                {
                    "id": 2,
                    "content": "参与答题必须从“小米社区App-内测中心-BL解锁申请-去答题”进入，其他方式进入答题将无法展示分数，但不影响后续申请",
                    "correct": false,
                    "explanation": "根据答题问卷页面提示，参与答题必须从“小米社区 App-内测中心-BL 解锁申请-去答题”进入。否则将影响后续申请。"
                },
                {
                    "id": 3,
                    "content": "参与答题必须从“小米社区App-内测中心-BL解锁申请-去答题”进入，其他方式进入答题将无法展示分数，影响后续申请",
                    "correct": true,
                    "explanation": "根据答题问卷页面提示，参与答题必须从“小米社区 App-内测中心-BL 解锁申请-去答题”进入。"
                },
                {
                    "id": 4,
                    "content": "本期答题的通过分数线为85分以上（不含85分）",
                    "correct": true,
                    "explanation": "根据答题问卷页面提示，本期答题通过分数线为 85 分以上（不含 85 分）。"
                },
                {
                    "id": 5,
                    "content": "租借/转让/借用BL解锁资格、“代答”等行为均属违规",
                    "correct": true,
                    "explanation": "根据解锁申请详细说明，租借/转让/借用 BL 解锁资格、“代答”等账号异常行为均属于违规，解锁申请不予通过，且账号将被封禁。"
                },
                {
                    "id": 6,
                    "content": "如果本次BL解锁申请通过，所获得的3次解锁资格，有效期至2024年12月31日",
                    "correct": true,
                    "explanation": "根据解锁申请详细说明，2024 年 1 月 1 日 00:00 及之后通过申请的用户解锁权限保留至申请当年 12 月 31 日 24:00。"
                },
                {
                    "id": 7,
                    "content": "BL解锁名额充足，满足申请条件后即可申请",
                    "correct": true,
                    "explanation": "目前解锁名额已由 2w 上调至为 5w 人，已通过人数仅 1.5w+，名额充足。"
                }
            ]
        },
        {
            "id": 3,
            "content": "已满足BL解锁申请条件，但申请后被拒绝的原因，下列说法正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "在社交媒介恶意诋毁、谩骂、造谣等",
                    "correct": true,
                    "explanation": "您不得在社交媒介对小米恶意诋毁、谩骂、造谣等。"
                },
                {
                    "id": 2,
                    "content": "出现被判定为作弊的行为",
                    "correct": true,
                    "explanation": "根据解锁申请详细说明，“代答”等账号异常行为属于违规，解锁申请不予通过，且账号将被封禁。"
                },
                {
                    "id": 3,
                    "content": "不填写申请理由、或使用AI生成申请理由、或申请理由出现过辱骂威胁等内容",
                    "correct": true,
                    "explanation": "您必须在申请时认真填写真实的申请理由。"
                },
                {
                    "id": 4,
                    "content": "其他违反小米账号使用协议的相关情形",
                    "correct": true,
                    "explanation": "您不得违反小米账号使用协议。"
                },
                {
                    "id": 5,
                    "content": "确认无任何违规情形，被拒绝后可尝试再次申请",
                    "correct": true,
                    "explanation": "如您无上述违规情形，在申请被拒绝后，可在 7 天后重新答题并申请。"
                }
            ]
        },
        {
            "id": 4,
            "content": "BL解锁面向发烧友和开发者开放，因此在资格筛选时，会考察是否符合发烧友的特质。下面关于发烧友的特质，说法正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "发烧友指的是对某一领域极度热爱，并对此领域的产品进行深入研究",
                    "correct": true,
                    "explanation": "公告类型题，对上一题的正确选项做出了解释。"
                },
                {
                    "id": 2,
                    "content": "发烧友具备探究精神，因此在遇到不了解的问题时，会在合理范围内主动探寻答案，但不会寻求不正当“捷径”或采用违规方式",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "发烧友具备坚韧不拔的品质，因此在遇到失败或挫折时，会不断尝试和努力，但不会去造谣、诋毁",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "发烧友具备学习精神，因此在遇到新鲜事物或新知识时，会乐于学习和钻研，但会肆意谩骂",
                    "correct": false,
                    "explanation": "发烧友是高素质人群，不会骂人。XD"
                },
                {
                    "id": 5,
                    "content": "发烧友具备学习精神，因此在遇到新鲜事物或新知识时，会乐于学习和钻研，但不会肆意谩骂",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 6,
                    "content": "发烧友具备分享精神，因此在有一些好的知识或经验时，会积极分享和交流，也会去利用“资源”去“谋利”",
                    "correct": false,
                    "explanation": "倒卖、代答等行为属于违规，小米在之前的公告中提及，已经处理过一批利用本题库资源代答谋利的用户。"
                },
                {
                    "id": 7,
                    "content": "发烧友具备分享精神，因此在有一些好的知识或经验时，会积极分享和交流，不会去利用“资源”去“谋利”",
                    "correct": true,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 5,
            "content": "BL解锁危害多，BL解锁可能造成各类App无法正常使用、个人数据信息泄露、手机变砖、资产损失等情况，因此强烈建议您非必要情况不申请BL解锁。请问您是否已经知悉以上风险和危害，并愿意承担以上全部风险和危害？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "本人愿意承担以上全部风险和危害，接受各类App无法正常使用、个人数据信息泄露、手机变砖、资产损失等情况",
                    "correct": true,
                    "explanation": "免责声明，不做解释。"
                },
                {
                    "id": 2,
                    "content": "本人不愿意承担以上全部风险和危害，立即关闭界面，停止答题和申请",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 6,
            "content": "关于本问卷中的填空题，请您务必认真阅读并了解以下注意事项",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "本问卷中的填空题共计___分，采用人工阅卷方式，人工阅卷预计在【下一周期答题开始前】完成",
                    "correct": true,
                    "explanation": "本期共有_____道填空题（含多项填空题），各为 8 分。根据答题前的页面提示，填空题为人工阅卷，预计在【下一周期答题开始前】完成。"
                },
                {
                    "id": 2,
                    "content": "您提交问卷时，系统所显示的成绩仅为【选择题得分】",
                    "correct": true,
                    "explanation": "根据答题前的页面提示，提交后的成绩仅为选择题得分。"
                },
                {
                    "id": 3,
                    "content": "人工阅卷后，如您的 选择题+填空题 总分【达到】分数线，系统会显示您的【选择题和填空题的总分】",
                    "correct": true,
                    "explanation": "根据答题前的页面提示，阅卷后总分达到分数线，将显示总分。"
                },
                {
                    "id": 4,
                    "content": "人工阅卷后，如您的  选择题+填空题 总分【未达到】分数线，系统仅显示您的【选择题得分】",
                    "correct": true,
                    "explanation": "根据答题前的页面提示，阅卷后总分未达到分数线，仅显示选择题得分。"
                },
                {
                    "id": 5,
                    "content": "请您及时关注答题分数变化，如您的答题分数达到分数线，请您务必在下一答题周期开始前申请解锁资格",
                    "correct": true,
                    "explanation": "根据解锁申请详细说明，答题分数仅当期有效，过时作废。"
                }
            ]
        },
        {
            "id": 7,
            "content": "请将上一题填写的其他技术交流平台贡献信息，上传相关截图凭证，以供审核使用",
            "type": "upload_file",
            "note": "非必填，此题的有效填写会提升审核通过率",
            "options": []
        },
        {
            "id": 8,
            "content": "如何解除手机Bootloader锁？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "进入MTK模式",
                    "correct": false,
                    "explanation": "MediaTek Preloader 是联发科（MediaTek, MTK）平台的机器进行深度刷机所使用的模式，可以无视 BootLoader 锁进行刷机。解锁 BootLoader 一般需要进入 fastboot 模式。"
                },
                {
                    "id": 2,
                    "content": "进入Recovery模式",
                    "correct": false,
                    "explanation": "解锁 BootLoader 一般需要进入 fastboot 模式，而不是 Recovery 模式。"
                },
                {
                    "id": 3,
                    "content": "申请解锁通过后，下载工具解锁",
                    "correct": true,
                    "explanation": "对于 Xiaomi/Redmi 手机，如需解锁 BootLoader，必须在解锁申请通过后，使用小米官方解锁工具进行解锁。"
                },
                {
                    "id": 4,
                    "content": "通过小米助手解锁",
                    "correct": false,
                    "explanation": "小米助手并没有解锁 BootLoader 的功能。小米助手是一款 PC 软件，能帮助您轻松连接 Xiaomi/Redmi 手机并管理手机中的 app、图片、音乐、视频等数据，且支持应用下载安装、数据备份还原等功能。"
                }
            ]
        },
        {
            "id": 9,
            "content": "请问如何实现保存数据刷机？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "备份数据—解Bootloader锁—线刷",
                    "correct": true,
                    "explanation": "对于 Xiaomi/Redmi 手机，解锁 BootLoader 会清除所有用户数据（Userdata 和 Metadata）。若希望保存数据，则解锁 BootLoader 前必须先备份数据。"
                },
                {
                    "id": 2,
                    "content": "解Bootloader锁—备份数据—线刷",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "解Bootloader锁—线刷—备份数据",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "解Bootloader锁—下载ROM—线刷",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 10,
            "content": "线刷需要手机进入什么模式？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "系统更新界面",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，进行 OTA 更新时，需要进入系统更新界面。"
                },
                {
                    "id": 2,
                    "content": "FASTBOOT界面",
                    "correct": true,
                    "explanation": "线刷时，需要先进入 fastboot 模式。"
                },
                {
                    "id": 3,
                    "content": "Recovery界面",
                    "correct": false,
                    "explanation": "卡刷时，需要进入 Recovery 模式。"
                }
            ]
        },
        {
            "id": 11,
            "content": "小米手机如何进入FASTBOOT模式？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "关机状态下长按音量+与音量-键",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机在关机状态下，按「音量加键」和「音量减键」将不会有任何反应。"
                },
                {
                    "id": 2,
                    "content": "关机状态下长按音量+键与电源键",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机在关机状态下，按「电源键」和「音量加键」通常会进入 Recovery 模式，而不是 fastboot 模式。"
                },
                {
                    "id": 3,
                    "content": "关机状态下长按音量-键与电源键",
                    "correct": true,
                    "explanation": "Xiaomi/Redmi 手机进入 fastboot 的组合键一般是「电源键」和「音量减键」。"
                },
                {
                    "id": 4,
                    "content": "关机状态下长按电源键",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机在关机状态下，单独按「电源键」只能正常开机。"
                }
            ]
        },
        {
            "id": 12,
            "content": "如何在FASTBOOT命令行内，刷入twrp到boot分区？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "fastboot flash update boot.img",
                    "correct": false,
                    "explanation": "flash 命令不存在 update 子命令。"
                },
                {
                    "id": 2,
                    "content": "fastboot flash recovery boot.img",
                    "correct": false,
                    "explanation": "执行该命令将会把 boot.img 刷入 recovery 分区。"
                },
                {
                    "id": 3,
                    "content": "fastboot flash boot boot.img",
                    "correct": true,
                    "explanation": "根据 fastboot 使用说明，刷入（flash）子命令格式为 flash PARTITION [FILENAME]，其中分区名为 boot，文件名任意。「不过，真的有人会闲得蛋疼把 TWRP 刷到 boot 分区里？有 recovery 分区不刷去刷 boot，不想开机了？小米你搞毛线呢？一开始就误导用户的题现在又搬出来凑数？」"
                },
                {
                    "id": 4,
                    "content": "fastboot flash update recovery boot.img",
                    "correct": false,
                    "explanation": "flash 命令不存在 update 子命令。"
                }
            ]
        },
        {
            "id": 13,
            "content": "FASTBOOT模式下如何输出防回滚机制（ANTI）版本号",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "fastboot -w ANTI",
                    "correct": false,
                    "explanation": "命令开关 -w 可以在任何子命令前添加，用于擦除设备中存储的所有用户数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 2,
                    "content": "fastboot -r ANTI",
                    "correct": false,
                    "explanation": "fastboot 不存在 -r 命令开关。"
                },
                {
                    "id": 3,
                    "content": "fastboot getvar anti",
                    "correct": true,
                    "explanation": "正确的输出小米防回滚机制（Xiaomi Anti-Rollback）版本号命令为 fastboot getvar anti。"
                },
                {
                    "id": 4,
                    "content": "fastboot devices",
                    "correct": false,
                    "explanation": "子命令 devices 用于列出已连接的设备列表。"
                }
            ]
        },
        {
            "id": 14,
            "content": "烧录img、bin、mbn、elf等镜像文件内容到指定分区，正确的指令是",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "fastboot getvar all <分区名>",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。all 表示输出全部信息，包括 product, devices, anti 等字段信息。"
                },
                {
                    "id": 2,
                    "content": "fastboot getvar anti <镜像文件名或路径>",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。anti 是小米特有的防回滚机制（Xiaomi Anti-Rollback）版本号。"
                },
                {
                    "id": 3,
                    "content": "fastboot getvar anti <镜像文件名与路径>",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。anti 是小米特有的防回滚机制（Xiaomi Anti-Rollback）版本号。"
                },
                {
                    "id": 4,
                    "content": "fastboot boot <内核镜像文件名或路径> <分区名>",
                    "correct": false,
                    "explanation": "子命令 boot 用于加载指定的镜像（通常是内核镜像）到设备的内存中用来临时启动，但不会将其实际刷写进设备的 boot 分区。这个命令通常用于测试和开发目的。"
                },
                {
                    "id": 5,
                    "content": "fastboot boot <镜像文件名或路径> <分区名>",
                    "correct": false,
                    "explanation": "子命令 boot 用于加载指定的镜像（通常是内核镜像）到设备的内存中用来临时启动，但不会将其实际刷写进设备的 boot 分区。这个命令通常用于测试和开发目的。"
                },
                {
                    "id": 6,
                    "content": "fastboot boot <分区名> <镜像文件名或路径>",
                    "correct": false,
                    "explanation": "子命令 boot 用于加载指定的镜像（通常是内核镜像）到设备的内存中用来临时启动，但不会将其实际刷写进设备的 boot 分区。这个命令通常用于测试和开发目的。"
                },
                {
                    "id": 7,
                    "content": "fastboot flash <分区名> <镜像文件名或路径>",
                    "correct": true,
                    "explanation": "根据 fastboot 使用说明，刷入（flash）子命令格式为 flash PARTITION [FILENAME]。"
                },
                {
                    "id": 8,
                    "content": "fastboot flash <镜像文件名或路径> <分区名>",
                    "correct": false,
                    "explanation": "根据 fastboot 使用说明，刷入（flash）子命令格式为 flash PARTITION [FILENAME]。"
                },
                {
                    "id": 9,
                    "content": "fastboot flash <镜像路径> <分区名>",
                    "correct": false,
                    "explanation": "根据 fastboot 使用说明，刷入（flash）子命令格式为 flash PARTITION [FILENAME]。"
                },
                {
                    "id": 10,
                    "content": "fastboot flash <镜像路径> <文件名>",
                    "correct": false,
                    "explanation": "根据 fastboot 使用说明，刷入（flash）子命令格式为 flash PARTITION [FILENAME]。"
                }
            ]
        },
        {
            "id": 15,
            "content": "在FASTBOOT模式中，手机通过什么方式连接到电脑？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "USB连接",
                    "correct": true,
                    "explanation": "在 fastboot 模式下，您需要使用 USB 连接手机和电脑，并使用命令行执行 fastboot 命令。"
                },
                {
                    "id": 2,
                    "content": "无线连接",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，fastboot 模式不支持无线连接。仅安卓调试桥（Android Debug Bridge, adb）支持无线连接。"
                },
                {
                    "id": 3,
                    "content": "蓝牙连接",
                    "correct": false,
                    "explanation": "fastboot 模式不支持蓝牙连接，蓝牙连接通常用于手机和其他智能设备的连接。"
                },
                {
                    "id": 4,
                    "content": "以太网连接",
                    "correct": false,
                    "explanation": "fastboot 模式不支持以太网连接，并且具备 WiFi 功能的手机无需通过以太网方式连接互联网。"
                }
            ]
        },
        {
            "id": 16,
            "content": "FASTBOOT命令中使用的标志“-w”代表什么操作？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "重启手机",
                    "correct": false,
                    "explanation": "子命令 reboot 用于重启设备。"
                },
                {
                    "id": 2,
                    "content": "下载最新完整包",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，要下载最新完整包，您可进入「设置-我的设备-MIUI（HyperOS）版本」，点击右上角「...」，选择「下载最新完整包」。"
                },
                {
                    "id": 3,
                    "content": "更新系统",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，要更新系统，您可进入「设置-我的设备-MIUI（HyperOS）版本」检查系统更新，或使用 Recovery 卡刷安装更新包，也可以在解锁 Bootloader 后使用 fastboot 线刷新版完整包。"
                },
                {
                    "id": 4,
                    "content": "清除所有数据",
                    "correct": true,
                    "explanation": "fastboot 命令开关 -w 可用于擦除设备中存储的所有用户数据。-w 开关可以在任何子命令前添加，用于擦除设备中存储的所有用户数据（Userdata 和 Metadata）。"
                }
            ]
        },
        {
            "id": 17,
            "content": "FASTBOOT getvar all 命令有何作用？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "输出该设备的所有信息",
                    "correct": true,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。all 表示输出全部信息，包括 product, devices, anti 等字段信息。"
                },
                {
                    "id": 2,
                    "content": "输出该设备的手机密码",
                    "correct": false,
                    "explanation": "设备的手机密码一经设置，就无法再通过任何方式二次查看。"
                },
                {
                    "id": 3,
                    "content": "输出该设备的手机号",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，fastboot 模式无法获取手机号。进入「设置-双卡与移动网络」，可以看到 SIM 卡 1 和 SIM 卡 2 的手机号。"
                },
                {
                    "id": 4,
                    "content": "输出该设备的更新版本",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，fastboot 模式无法获取系统版本。进入「设置-我的设备-全部参数与信息」，可以查看 Android 版本、 MIUI 版本（或 HyperOS 版本）以及其他版本信息。"
                }
            ]
        },
        {
            "id": 18,
            "content": "在FASTBOOT模式下，什么是用于刷写固件的命令？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "load",
                    "correct": false,
                    "explanation": "fastboot 不存在 load 子命令。"
                },
                {
                    "id": 2,
                    "content": "run",
                    "correct": false,
                    "explanation": "fastboot 不存在 run 子命令。"
                },
                {
                    "id": 3,
                    "content": "boot",
                    "correct": false,
                    "explanation": "子命令 boot 用于加载指定的镜像（通常是内核镜像）到设备的内存中用来临时启动，但不会将其实际刷写进设备的 boot 分区。这个命令通常用于测试和开发目的。"
                },
                {
                    "id": 4,
                    "content": "flash",
                    "correct": true,
                    "explanation": "子命令 flash 用于向目标分区刷入指定镜像。"
                }
            ]
        },
        {
            "id": 19,
            "content": "FASTBOOT模式和Recovery模式有什么区别？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "Recovery能直接进入安全模式",
                    "correct": false,
                    "explanation": "通过重启到 Recovery 并选择以安全模式启动，能够仅加载核心系统和预安装的应用程序，而不加载用户安装的第三方应用程序和服务。该方式通常用于排查正常模式启动后出现的问题是否由第三方应用程序造成。"
                },
                {
                    "id": 2,
                    "content": "FASTBOOT模式指的是“线刷”",
                    "correct": false,
                    "explanation": "fastboot 模式刷机需要使用 USB 连接手机和电脑，通过将电脑上的镜像传输至手机进行刷入操作，因此得名「线刷」。"
                },
                {
                    "id": 3,
                    "content": "Recovery模式指的是“卡刷”",
                    "correct": false,
                    "explanation": "Recovery 模式刷机无需连接电脑，可以选择内部存储设备（或存储卡）中的刷机包直接进行刷入操作，因此得名「卡刷」。"
                },
                {
                    "id": 4,
                    "content": "全部都对",
                    "correct": true,
                    "explanation": "以上选项均为正确描述。"
                }
            ]
        },
        {
            "id": 20,
            "content": "MiFlash的全部删除是什么意思？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "删除包括Data在内的全部数据",
                    "correct": true,
                    "explanation": "使用 MiFlash 进行刷机，若选择全部删除，则会清除所有用户数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 2,
                    "content": "删除小米云服务数据",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，您可进入「设置-小米账号-小米云服务」，或者登录 i.mi.com 来删除小米云服务相关数据。"
                },
                {
                    "id": 3,
                    "content": "删除小米商城购物车内所有数据",
                    "correct": false,
                    "explanation": "您可进入「小米商城」APP，点击「购物车」选项卡，点击右上角「编辑」按钮，然后在下方勾选「全选」按钮，最后点击「删除」按钮即可删除小米商城购物车内所有数据。"
                },
                {
                    "id": 4,
                    "content": "删除米家连接设备",
                    "correct": false,
                    "explanation": "您可进入「米家」APP，长按您要删除的设备，出现「✓」后，点击下方「更多-删除设备」即可删除该设备。"
                },
                {
                    "id": 5,
                    "content": "~~删除小米社区所有数据~~",
                    "correct": false,
                    "explanation": "~~您可进入「小米社区」APP，点击「我的」选项卡，点击右上角「齿轮」按钮，然后进入「隐私管理-注销小米社区服务」，点击下方「注销小米社区账号」按钮，勾选「本人已阅读并知晓注销协议」，最后点击最下方「确认注销」按钮即可全部删除。~~"
                }
            ]
        },
        {
            "id": 21,
            "content": "FASTBOOT模式进入后是什么样子？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "屏幕上显示Xiaomi",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "屏幕上显示Redmi",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "屏幕上显示英文FASTBOOT",
                    "correct": true,
                    "explanation": "该描述是正确的。对于早期 MIUI 版本，也可能显示为「一只米兔正在维修一个安卓机器人」的画面。（最新版本米兔已消失，~~被金凡拉去炖汤了~~）"
                }
            ]
        },
        {
            "id": 22,
            "content": "Xiaomi/Redmi手机如何进入Recovery模式？",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "关机状态下长按电源键和音量减键",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机在关机状态下，按「电源键」和「音量减键」通常会进入 fastboot 模式，而不是 Recovery 模式。"
                },
                {
                    "id": 2,
                    "content": "关机状态下长按音量加键和电源键",
                    "correct": true,
                    "explanation": "Xiaomi/Redmi 手机进入 Recovery 的组合键一般是「电源键」和「音量加键」。"
                },
                {
                    "id": 3,
                    "content": "关机状态下长按音量加键和音量减键",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机在关机状态下，按「音量加键」和「音量减键」将不会有任何反应。"
                },
                {
                    "id": 4,
                    "content": "关机状态下长按电源键",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机在关机状态下，单独按「电源键」只能正常开机。"
                }
            ]
        },
        {
            "id": 23,
            "content": "安卓系统中负责启动应用，管理应用生命周期的系统服务是",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "ActivityManagerSystem",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "ActivitySystemManager",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "ActivityManagerService",
                    "correct": true,
                    "explanation": "在 Android 系统中，负责上述操作的系统服务为 AMS，全称为 Activity Manager Service。"
                },
                {
                    "id": 4,
                    "content": "ApplicationManagerService",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 24,
            "content": "MTK刷机时，报错4004的意思是",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "驱动问题",
                    "correct": true,
                    "explanation": "该报错代码表示驱动问题。"
                },
                {
                    "id": 2,
                    "content": "内存损坏",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "刷机软件版本不匹配",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "ROM文件和手机系统差距太大",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 25,
            "content": "fastboot oem reboot-recovery的作用是",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "退出FASTBOOT模式并重启进入Recovery模式",
                    "correct": true,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，reboot-recovery 会将设备重启至 Recovery 模式。"
                },
                {
                    "id": 2,
                    "content": "退出FASTBOOT模式并重启进入系统",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "退出FASTBOOT模式并重启进入EDL模式",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "退出FASTBOOT模式并关机",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 26,
            "content": "输入fastboot devices命令后，可能输出的结果是",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "$ wget https://xxx.xxx/xxx/xxx/xxx.img",
                    "correct": false,
                    "explanation": "该内容为用户手动输入的指令。"
                },
                {
                    "id": 2,
                    "content": "MBR: verify success!",
                    "correct": false,
                    "explanation": "该内容为引导加载程序的日志。"
                },
                {
                    "id": 3,
                    "content": "remount failed",
                    "correct": false,
                    "explanation": "该内容为挂载（mount）命令的报错。"
                },
                {
                    "id": 4,
                    "content": "XMABC100-01 fastboot",
                    "correct": true,
                    "explanation": "fastboot 子命令 devices 的输出格式为空（即无设备连接）或「<序列号> fastboot」（如有多个设备同时连接，则每行会显示一个设备）。"
                }
            ]
        },
        {
            "id": 27,
            "content": "现计划展出10台小米/Redmi手机，具体如下：3台Redmi K70（已BL解锁）、3台小米13（未BL解锁）、1台小米14Pro（未BL解锁）、3台Redmi K60至尊版（未BL解锁），现将这10台手机排成一列进行展示，但已BL解锁的手机不能挨在一起，请问有多少种展出陈列方式（同一机型视为完全一样）",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "2240",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "2352",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "7840",
                    "correct": true,
                    "explanation": "数学排列组合问题。根据题意可以有两种思路列式计算: $$C_7^3 \\times C_4^3 \\times C_8^3 = 7840$$ $$\\frac {A_7^7} {(A_3^3)^2} \\times C_8^3 = 7840$$"
                },
                {
                    "id": 4,
                    "content": "8960",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 5,
                    "content": "10080",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 28,
            "content": "若short型变量x=-8190，则x的机器数为",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "E002H",
                    "correct": true,
                    "explanation": "short 为 16 位有符号整型，最高位为符号位， $-8190=-(8192-2)$ $=-((2^{13}-1)-1)$， $2^{13}-1$ 的二进制表示为 13 个 1，[x]原 = 1001 1111 1111 1110B，将原码除符号位外取反加 1 转换为补码，[x]补 = 1110 0000 0000 0010B = E002H。"
                },
                {
                    "id": 2,
                    "content": "9FFFH",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "E001H",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "9FFEH",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 29,
            "content": "执行以下哪些操作需要解Bootloader锁？",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "卡刷方法刷机",
                    "correct": false,
                    "explanation": "卡刷一般不需要解锁 BootLoader，但在 BootLoader 上锁状态下使用官方 Recovery 无法进行降级（小米官方并不提供降级包）、刷第三方 ROM 等操作。"
                },
                {
                    "id": 2,
                    "content": "FASTBOOT模式下线刷",
                    "correct": true,
                    "explanation": "线刷前必须先解锁 BootLoader。"
                },
                {
                    "id": 3,
                    "content": "ROOT权限",
                    "correct": true,
                    "explanation": "要想成功刷入经过修补的 boot/init_boot 以获取 root 权限，则必须先关闭设备的 DM-Verity（完整性校验），因此必须先解锁 BootLoader。"
                },
                {
                    "id": 4,
                    "content": "线刷开发版ROM",
                    "correct": true,
                    "explanation": "线刷前必须先解锁 BootLoader。"
                }
            ]
        },
        {
            "id": 30,
            "content": "下列关于BL解锁的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "BL锁可以防止用户在设备上安装非官方或未授权的操作系统",
                    "correct": false,
                    "explanation": "BootLoader 锁在设计上的用途即为此。"
                },
                {
                    "id": 2,
                    "content": "正式版切换到开发版一般不需要BL解锁",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机的正式版切换到开发版通常不需要解锁，部分机型仍然有例外情况。最新的设备已不再提供开发版。"
                },
                {
                    "id": 3,
                    "content": "解锁时需要登录小米账号",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 手机解锁 BootLoader 需要登录并绑定小米账号。"
                },
                {
                    "id": 4,
                    "content": "解锁时小米账号不需要与手机绑定",
                    "correct": true,
                    "explanation": "Xiaomi/Redmi 手机解锁 BootLoader 需要登录并绑定小米账号。"
                },
                {
                    "id": 5,
                    "content": "解锁后系统的安全系数不会降低",
                    "correct": true,
                    "explanation": "解锁 BootLoader 后，设备安全无任何保证，存储的数据将丢失，用户使用已解锁的设备可能会因此遭受经济损失。"
                }
            ]
        },
        {
            "id": 31,
            "content": "下列刷机工具中，不属于官方提供给用户的工具是？",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "MIUI一键刷机",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "刷机大师",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 3,
                    "content": "线刷宝",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "91助手",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 5,
                    "content": "MiFlash",
                    "correct": false,
                    "explanation": "除 MiFlash（及 MiFlashPro）外，其余工具均为非官方工具。"
                }
            ]
        },
        {
            "id": 32,
            "content": "FastBoot命令有哪些类型",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "执行动作类",
                    "correct": true,
                    "explanation": "比如，子命令 oem 中的 poweroff 用于关机，子命令 oem 中的 lock 用于给 BootLoader 重新上锁等。"
                },
                {
                    "id": 2,
                    "content": "数据备份类",
                    "correct": false,
                    "explanation": "fastboot 不存在用于备份数据的子命令。"
                },
                {
                    "id": 3,
                    "content": "输出信息类",
                    "correct": true,
                    "explanation": "比如，子命令 getvar 用于从 BootLoader 中读取手机信息。"
                },
                {
                    "id": 4,
                    "content": "擦写数据类",
                    "correct": true,
                    "explanation": "比如，子命令 erase 和 format 用于擦除指定分区的所有数据，子命令 flash 用于向目标分区刷入指定镜像。"
                }
            ]
        },
        {
            "id": 33,
            "content": "关于FASTBOOT devices的作用，错误的说法有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "列出当前已进入FASTBOOT模式，且与PC连接正常的所有设备",
                    "correct": false,
                    "explanation": "子命令 devices 用于列出已连接且处于 fastboot 模式的设备列表。"
                },
                {
                    "id": 2,
                    "content": "列出当前已进入Recovery模式，且与PC连接正常的所有设备",
                    "correct": true,
                    "explanation": "没有专门用于列出所有处于 Recovery 模式的设备的命令。"
                },
                {
                    "id": 3,
                    "content": "无响应命令检测",
                    "correct": true,
                    "explanation": "应用程序无响应也称 ANR（Application Not Responding），通常是由于应用程序未能在一定时间内响应用户操作而触发的。您可使用 adb logcat | grep \"ANR\" 命令，该命令可以从系统日志中筛选出包含 \"ANR\" 的行，以供您进一步分析。"
                },
                {
                    "id": 4,
                    "content": "检查手机是否已经更新",
                    "correct": true,
                    "explanation": "对于 Xiaomi/Redmi 手机，您可进入「设置-我的设备-MIUI（HyperOS）版本」检查系统更新状态。"
                }
            ]
        },
        {
            "id": 34,
            "content": "线刷可以用来解决哪些场景问题？",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "降级回到之前的系统版本",
                    "correct": true,
                    "explanation": "在不触及小米防回滚机制（Xiaomi Anti-Rollback）的情况下，可以通过线刷降级系统版本。"
                },
                {
                    "id": 2,
                    "content": "彻底删除设备数据",
                    "correct": true,
                    "explanation": "线刷可以删除所有设备数据。"
                },
                {
                    "id": 3,
                    "content": "解决已解锁手机无法开机的问题",
                    "correct": true,
                    "explanation": "线刷可以用来救砖。"
                },
                {
                    "id": 4,
                    "content": "恢复误删除数据",
                    "correct": false,
                    "explanation": "线刷无法恢复数据。"
                }
            ]
        },
        {
            "id": 35,
            "content": "FASTBOOT模式通常用于哪些操作？",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "传输大型文件",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，要传输大型文件，在手机连接电脑后，选择将 USB 用于「传输文件」即可。"
                },
                {
                    "id": 2,
                    "content": "解锁引导加载程序",
                    "correct": true,
                    "explanation": "解锁 BootLoader 需要在 fastboot 模式下操作。对于 Xiaomi/Redmi 手机，如需解锁 BootLoader，必须在解锁申请通过后，使用小米官方解锁工具进行解锁。"
                },
                {
                    "id": 3,
                    "content": "更新设备驱动程序",
                    "correct": false,
                    "explanation": "您可通过系统更新的方式来同步更新设备驱动程序。"
                },
                {
                    "id": 4,
                    "content": "启用设备无线功能",
                    "correct": false,
                    "explanation": "一般情况下，您可进入「设置-WLAN」并打开「WLAN」开关以启用设备无线功能。"
                },
                {
                    "id": 5,
                    "content": "刷写设备固件",
                    "correct": true,
                    "explanation": "在 fastboot 模式下，执行子命令 flash PARTITION [FILENAME] 可以向目标分区刷入指定镜像。"
                },
                {
                    "id": 6,
                    "content": "大量文件数据传输",
                    "correct": false,
                    "explanation": "对于 Xiaomi/Redmi 手机，要传输大型文件，在手机连接电脑后，选择将 USB 用于「传输文件」即可。"
                }
            ]
        },
        {
            "id": 36,
            "content": "输入“adb logcat”后，出现“waiting for device”信息，可能的原因是",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "在线ota升级后没自动双清",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "设备没有连接计算机",
                    "correct": true,
                    "explanation": "该信息的含义为 【等待 device 模式的设备连接】，可能出现的原因有以下几点：1）驱动未安装或出现异常，计算机无法识别设备；2）设备没有物理连接到计算机，可检查接口是否松动或数据线是否正常；3）设备不在 device 模式，或未授权计算机；4）设备没有启用「USB 调试」功能。"
                },
                {
                    "id": 3,
                    "content": "ADB驱动程序没正确安装",
                    "correct": true,
                    "explanation": ""
                },
                {
                    "id": 4,
                    "content": "安装包签名不一致",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 37,
            "content": "下列关于BL解锁刷机的说法，不正确的是",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "刷入第三方TWRP，通常选择刷入到system分区",
                    "correct": true,
                    "explanation": "TWRP 通常刷入到 Recovery 分区。"
                },
                {
                    "id": 2,
                    "content": "刷入第三方Recovery，通常数据不会丢失",
                    "correct": true,
                    "explanation": "刷入第三方 Recovery 通常不会涉及数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 3,
                    "content": "刷入第三方Recovery，个人数据通常会丢失",
                    "correct": true,
                    "explanation": "刷入第三方 Recovery 通常不会涉及数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 4,
                    "content": "擦除cache分区数据，个人数据通常会丢失",
                    "correct": true,
                    "explanation": "擦除缓存（cache）分区数据，通常不会涉及个人数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 5,
                    "content": "擦除cache分区数据，个人数据通常不会丢失",
                    "correct": false,
                    "explanation": "擦除缓存（cache）分区数据，通常不会涉及个人数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 6,
                    "content": "线刷刷机前，应当备份重要数据",
                    "correct": false,
                    "explanation": "线刷刷机可能会清除所有数据，重要数据需要在刷机前备份。"
                },
                {
                    "id": 7,
                    "content": "线刷刷机前，无需备份重要数据",
                    "correct": true,
                    "explanation": "线刷刷机可能会清除所有数据，重要数据需要在刷机前备份。"
                },
                {
                    "id": 8,
                    "content": "线刷前不建议备份重要数据",
                    "correct": true,
                    "explanation": "线刷刷机可能会清除所有数据，重要数据需要在刷机前备份。"
                },
                {
                    "id": 9,
                    "content": "线刷可以用来降级回到之前的系统版本、彻底删除设备数据、恢复误删除数据等",
                    "correct": true,
                    "explanation": "线刷无法恢复数据。"
                },
                {
                    "id": 10,
                    "content": "线刷可以用来降级回到之前的系统版本、彻底删除设备数据等",
                    "correct": false,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 11,
                    "content": "线刷不可以用来降级回到之前的系统版本、彻底删除设备数据等",
                    "correct": true,
                    "explanation": "线刷具备上述功能。"
                },
                {
                    "id": 12,
                    "content": "线刷开发版ROM需要解锁Bootloader",
                    "correct": true,
                    "explanation": "线刷前必须先解锁 BootLoader。"
                },
                {
                    "id": 13,
                    "content": "线刷开发版ROM不需要解锁Bootloader",
                    "correct": true,
                    "explanation": "线刷前必须先解锁 BootLoader。"
                },
                {
                    "id": 14,
                    "content": "在FASTBOOT模式下，用flash命令刷写固件",
                    "correct": false,
                    "explanation": "根据 fastboot 使用说明，刷入（flash）子命令格式为 flash PARTITION [FILENAME]。"
                },
                {
                    "id": 15,
                    "content": "刷机过程中出现Missmatching image and device报错，可以直接修改脚本强刷，不会变砖",
                    "correct": true,
                    "explanation": "该报错表示欲刷入的镜像与设备不匹配，强行刷入可能会导致设备无法启动。任何报错都不建议修改脚本强刷。"
                },
                {
                    "id": 16,
                    "content": "刷机过程中出现的Missmatching image and device报错，不可以直接修改脚本强刷",
                    "correct": true,
                    "explanation": "该报错表示欲刷入的镜像与设备不匹配，强行刷入可能会导致设备无法启动。任何报错都不建议修改脚本强刷。"
                },
                {
                    "id": 17,
                    "content": "刷机过程中碰到数据线可能导致报错，重新刷机即可",
                    "correct": false,
                    "explanation": "刷机过程中碰到数据线可能导致设备与计算机的连接断开，从而引发报错。此时设备可能无法正常启动，重新连接设备后刷机即可。"
                },
                {
                    "id": 18,
                    "content": "刷机过程中，出现Flash antirbpass error的报错，可以直接修改脚本强刷",
                    "correct": true,
                    "explanation": "该报错意味着欲刷入镜像与设备中已有的小米防回滚机制（Xiaomi Anti-Rollback）冲突，强行刷入可能会无法开机。任何报错都不建议修改脚本强刷。"
                },
                {
                    "id": 19,
                    "content": "刷机过程中，出现Flash antirbpass error的报错，不可以直接修改脚本强刷",
                    "correct": false,
                    "explanation": "该报错意味着欲刷入镜像与设备中已有的小米防回滚机制（Xiaomi Anti-Rollback）冲突，强行刷入可能会无法开机。任何报错都不建议修改脚本强刷。"
                }
            ]
        },
        {
            "id": 38,
            "content": "MTK刷机的报错，原因不匹配的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "S_UNSUPPORTED_OPERATION：已存在同名的程序",
                    "correct": true,
                    "explanation": "该报错意味着刷机引导文件 Scatter.txt 与设备不匹配。"
                },
                {
                    "id": 2,
                    "content": "S_DA_EMMC_FLASH_NOT_FOUND：手机的内存己经损坏",
                    "correct": true,
                    "explanation": "该报错意味着刷机引导文件 Scatter.txt 与设备不匹配。"
                },
                {
                    "id": 3,
                    "content": "S_FT_NEED_DOWNLOAD_ALL_FAIL：目标ROM文件和手机系统差距过大",
                    "correct": false,
                    "explanation": "该报错意味着目标 ROM 文件和手机的系统差距过大，通常在单刷某个分区时会出现。"
                },
                {
                    "id": 4,
                    "content": "S_BROM_CMD_STARTCMD_FAIL：没有加载好刷机包文件",
                    "correct": true,
                    "explanation": "该报错意味着没有加载好刷机包的文件或驱动没装好。"
                },
                {
                    "id": 5,
                    "content": "S_CHIP_TYPE_NOT_MATCH：没有加载好刷机包文件",
                    "correct": true,
                    "explanation": "该报错意味着刷机包适配的芯片型号与设备不匹配。"
                },
                {
                    "id": 6,
                    "content": "S_CHIP_TYPE_NOT_MATCH：文件类型不匹配",
                    "correct": true,
                    "explanation": "该报错意味着刷机包适配的芯片型号与设备不匹配。"
                },
                {
                    "id": 7,
                    "content": "S_BROM_CMD_STARTCMD_FAIL：文件类型不匹配",
                    "correct": true,
                    "explanation": "该报错意味着没有加载好刷机包的文件或驱动没装好。"
                }
            ]
        },
        {
            "id": 39,
            "content": "下列关于清除数据的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "刷机过程中，刷入的系统版本与原系统差异较大时，通常建议执行四清",
                    "correct": true,
                    "explanation": "当刷入系统差异较大时，如果不完整清除数据，可能会无法开机。这里的四清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）、系统缓存（Cache）以及账户锁（Frp）。"
                },
                {
                    "id": 2,
                    "content": "刷机过程中，刷入的系统版本与原系统差异较大时，通常建议执行三清",
                    "correct": true,
                    "explanation": "当刷入系统差异较大时，如果不完整清除数据，可能会无法开机，所以三清是不够的，往往需要四清。三清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）和系统缓存（Cache）；四清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）、系统缓存（Cache）以及账户锁（Frp）。"
                },
                {
                    "id": 3,
                    "content": "刷机过程中，刷入的系统版本与原系统差异较大时，通常建议执行二清",
                    "correct": true,
                    "explanation": "当刷入系统差异较大时，如果不完整清除数据，可能会无法开机，所以二清是不够的，往往需要四清。二清指的是用户数据（Userdata 或 Data）和系统缓存（Cache）；四清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）、系统缓存（Cache）以及账户锁（Frp）。"
                },
                {
                    "id": 4,
                    "content": "对于刷入系统包的操作，通常建议执行四清",
                    "correct": true,
                    "explanation": "当刷入的系统包差异较小时，通常不需要四清，而只需要三清即可。这里的三清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）和系统缓存（Cache）。"
                },
                {
                    "id": 5,
                    "content": "对于刷入系统包的操作，通常建议执行三清",
                    "correct": true,
                    "explanation": "当刷入的系统包差异较小时，通常只需要三清即可。这里的三清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）和系统缓存（Cache）。"
                },
                {
                    "id": 6,
                    "content": "三清后不刷入系统，通常无法开机进入系统",
                    "correct": true,
                    "explanation": "三清指的是用户数据（Userdata 或 Data）、加密元数据（Metadata）和系统缓存（Cache），不涉及系统分区，通常不会造成无法开机的问题。"
                },
                {
                    "id": 7,
                    "content": "双清通常是指的清除Data、Cache",
                    "correct": false,
                    "explanation": "双清指的是是用户数据（Userdata 或 Data）和系统缓存（Cache）。但对于 A/B 分区格式（和/或虚拟 A/B 分区格式）的新设备，不存在独立的系统缓存（Cache）分区，系统缓存（Cache）存储在用户数据（Userdata 或 Data）分区下。"
                }
            ]
        },
        {
            "id": 40,
            "content": "手机如只能进入FASTBOOT，下列说法正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "可能是系统已经损坏",
                    "correct": true,
                    "explanation": "手机如只能进入 fastboot，可能是系统损坏，比如开机无法启动并显示红色感叹号和「System has been destroyed」。"
                },
                {
                    "id": 2,
                    "content": "可能是引导程序损毁",
                    "correct": true,
                    "explanation": "引导程序损毁可能导致只能进入 fastboot 模式或完全无法启动。所以，如果手机只能进入 fastboot，有可能是引导程序损毁造成的。"
                },
                {
                    "id": 3,
                    "content": "不可能是引导程序损毁",
                    "correct": true,
                    "explanation": "引导程序损毁可能导致只能进入 fastboot 模式或完全无法启动。所以，如果手机只能进入 fastboot，有可能是引导程序损毁造成的。"
                }
            ]
        },
        {
            "id": 41,
            "content": "以下FASTBOOT基本命令，对应正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "fastboot getvar all：列出当前已进入FASTBOOT模式，且与PC连接正常的所有设备",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。all 表示输出全部信息，包括 product, devices, anti 等字段信息。若想列出已连接的 fastboot 模式设备，请使用 devices 子命令。"
                },
                {
                    "id": 2,
                    "content": "fastboot getvar all：输出当前BL锁状态（非MTK）",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。all 表示输出全部信息，其中虽然包含 BootLoader 解锁状态，但该命令通常不用做是否已解锁判断。"
                },
                {
                    "id": 3,
                    "content": "fastboot getvar anti：列出当前已进入FASTBOOT模式，且与PC连接正常的所有设备",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。anti 是小米特有的防回滚机制（Xiaomi Anti-Rollback）版本号。"
                },
                {
                    "id": 4,
                    "content": "fastboot getvar code：输出该机型的内部代号名称",
                    "correct": false,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。product 表示机型内部代号，通常用于判断镜像是否与设备相符。对于 Xiaomi/Redmi 手机，子命令 getvar 不存在 code 字段。"
                },
                {
                    "id": 5,
                    "content": "fastboot getvar product：输出该机型内部代号名称",
                    "correct": true,
                    "explanation": "子命令 getvar 用于从 BootLoader 中读取手机信息。product 表示机型内部代号，通常用于判断镜像是否与设备相符。"
                },
                {
                    "id": 6,
                    "content": "fastboot wipe <分区名>：擦除分区内数据",
                    "correct": true,
                    "explanation": "fastboot 不存在 wipe 子命令。正确的子命令应该是 erase PARTITION。"
                },
                {
                    "id": 7,
                    "content": "fastboot erase <分区名>：清除手机中所有数据",
                    "correct": false,
                    "explanation": "子命令 erase 仅用于擦除指定分区的所有数据。如果要擦除设备中存储的所有用户数据（Userdata 和 Metadata），可以在任何子命令前添加 -w 命令开关，或直接执行 fastboot erase userdata（或 fastboot erase data）。"
                },
                {
                    "id": 8,
                    "content": "fastboot erase <分区名>：擦除分区数据",
                    "correct": true,
                    "explanation": "子命令 erase 用于擦除指定分区的所有数据。"
                },
                {
                    "id": 9,
                    "content": "fastboot erase system：擦除全部数据",
                    "correct": true,
                    "explanation": "子命令 erase 用于擦除指定分区的所有数据。system 为 Android 系统分区，擦除该分区并不影响用户数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 10,
                    "content": "fastboot erase system：擦除系统分区",
                    "correct": true,
                    "explanation": "子命令 erase 用于擦除指定分区的所有数据。system 为 Android 系统分区。"
                },
                {
                    "id": 11,
                    "content": "fastboot erase userdata：清除手机中所有数据",
                    "correct": true,
                    "explanation": "子命令 erase 用于擦除指定分区的所有数据。userdata 分区为手机数据保存的分区。"
                },
                {
                    "id": 12,
                    "content": "fastboot -r：擦除设备上的所有数据",
                    "correct": true,
                    "explanation": "fastboot 不存在 -r 命令开关。如果要擦除设备中存储的所有用户数据（Userdata 和 Metadata），正确的命令开关应为 -w。"
                },
                {
                    "id": 13,
                    "content": "fastboot -w：列出当前已进入FASTBOOT模式，且与PC连接正常的所有设备",
                    "correct": false,
                    "explanation": "fastboot 命令开关 -w 可用于擦除设备中存储的所有用户数据。-w 开关可以在任何子命令前添加，用于擦除设备中存储的所有用户数据（Userdata 和 Metadata）。若想列出已连接的 fastboot 模式设备，请使用 devices 子命令。"
                },
                {
                    "id": 14,
                    "content": "fastboot -w：擦除设备上所有数据",
                    "correct": true,
                    "explanation": "fastboot 命令开关 -w 可用于擦除设备中存储的所有用户数据。-w 开关可以在任何子命令前添加，用于擦除设备中存储的所有用户数据（Userdata 和 Metadata）。"
                },
                {
                    "id": 15,
                    "content": "fastboot oem device-info：输出该设备的所有信息",
                    "correct": false,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，device-info 命令将仅能输出如下设备状态消息：Verity mode（完整性校验状态），刷入非官方镜像需要禁用，为 false 时表示已禁用完整性校验；Device unlocked（BootLoader 解锁状态），为 true 时表示已解锁；Device critical unlocked（关键分区解锁状态），为 true 时表示 BootLoader 已完整解锁；Charger screen enabled（关机充电屏幕状态）。"
                },
                {
                    "id": 16,
                    "content": "fastboot oem device-info：输出当前BL锁状态",
                    "correct": true,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，device-info 命令将输出如下设备状态：Verity mode（完整性校验状态），刷入非官方镜像需要禁用，为 false 时表示已禁用完整性校验；Device unlocked（BootLoader 解锁状态），为 true 时表示已解锁；Device critical unlocked（关键分区解锁状态），为 true 时表示 BootLoader 已完整解锁；Charger screen enabled（关机充电屏幕状态）。"
                },
                {
                    "id": 17,
                    "content": "fastboot oem poweroff：清除手机中所有数据后关机",
                    "correct": false,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，poweroff 命令只会关机，不会清除数据。"
                },
                {
                    "id": 18,
                    "content": "fastboot oem lock：获取root权限",
                    "correct": false,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，lock 命令为回锁（开启 BootLoader 锁保护）命令，执行后需重新解锁（关闭 BootLoader 锁保护）后方可获取 root 权限。如需获取 root 权限，您需要在解锁 BootLoader 后刷入经过 Magisk 修补的 init_boot（如手机无此分区，则刷入经过修补的 boot）。"
                },
                {
                    "id": 19,
                    "content": "fastboot oem lock：解锁设备",
                    "correct": false,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，lock 命令为回锁（开启 BootLoader 锁保护）命令，unlock 命令才是解锁（关闭 BootLoader 锁保护）命令。但对于 Xiaomi/Redmi 手机，单独执行 unlock 子命令并不生效，如需解锁，请使用小米官方解锁工具。"
                },
                {
                    "id": 20,
                    "content": "fastboot oem lock：开启BL锁保护",
                    "correct": true,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，lock 命令为回锁（开启 BootLoader 锁保护）命令。"
                },
                {
                    "id": 21,
                    "content": "fastboot oem lks：输出当前BL锁状态（MTK）",
                    "correct": true,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 MTK 平台的 Xiaomi/Redmi 手机，lks 命令通常用于查询解锁状态，输出为 lks=0 时表示已解锁。"
                },
                {
                    "id": 22,
                    "content": "fastboot devices：列出当前已进入FASTBOOT模式，且与PC连接正常的所有设备",
                    "correct": true,
                    "explanation": "子命令 devices 用于列出已连接且处于 fastboot 模式的设备列表。"
                },
                {
                    "id": 23,
                    "content": "fastboot reboot：重启手机",
                    "correct": true,
                    "explanation": "子命令 reboot 用于重启设备。"
                },
                {
                    "id": 24,
                    "content": "fastboot reboot：输出FASTBOOT模式下连接的设备",
                    "correct": false,
                    "explanation": "子命令 reboot 用于重启设备。若想列出已连接的 fastboot 模式设备，请使用 devices 子命令。"
                },
                {
                    "id": 25,
                    "content": "fastboot reboot：列出当前已进入FASTBOOT模式，且与PC连接正常的所有设备",
                    "correct": false,
                    "explanation": "子命令 reboot 用于重启设备。若想列出已连接的 fastboot 模式设备，请使用 devices 子命令。"
                },
                {
                    "id": 26,
                    "content": "fastboot flashing unlock：获取root权限",
                    "correct": true,
                    "explanation": "子命令 flashing unlock 仅可对部分品牌的手机进行 BootLoader 解锁。执行该命令不能直接获取到 root 权限。如需获取 root 权限，您需要在解锁 BootLoader 后刷入经过 Magisk 修补的 init_boot（如手机无此分区，则刷入经过修补的 boot）。同时，对于 Xiaomi/Redmi 手机，单独执行 flashing unlock 子命令并不能成功解锁 BootLoader，您需要使用小米官方解锁工具才能进行解锁。该工具的工作原理是：在登录小米账号并连接设备后，点击解锁按钮，解锁工具将向小米解锁服务器提交小米账号凭据、设备在 fastboot getvar 中获取到的 product 和 token 字段。若成功收到服务器下发的动态解锁码，则将其写入设备并执行 oem unlock 子命令以解锁 BootLoader；反之，解锁工具将会提示对应的错误信息。"
                },
                {
                    "id": 27,
                    "content": "fastboot delete：擦除所有分区",
                    "correct": false,
                    "explanation": "fastboot 不存在 delete 子命令。同时，亦不存在能直接擦除所有分区的命令。"
                }
            ]
        },
        {
            "id": 42,
            "content": "如何退出FASTBOOT模式？",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "在FASTBOOT模式下长按电源键约7-15秒重启进入系统",
                    "correct": true,
                    "explanation": "长按「电源键」可以强制重启。"
                },
                {
                    "id": 2,
                    "content": "在FASTBOOT模式下长按音量键约7-15秒重启进入系统",
                    "correct": false,
                    "explanation": "长按「电源键」可以强制重启，并非「音量键」。"
                },
                {
                    "id": 3,
                    "content": "通过“fastboot reboot”及“fastboot oem poweroff”命令重启进入系统或拔线关机",
                    "correct": true,
                    "explanation": "子命令 oem 为制造商自定义命令。对于 Xiaomi/Redmi 手机，上述命令为正确重启或关机命令。"
                },
                {
                    "id": 4,
                    "content": "部分机型在FASTBOOT模式下插入数据线，5分钟到半小时内会自动重启或关机",
                    "correct": false,
                    "explanation": "部分机型在未连接（数据线拔出）时，5 分钟到半小时内才会自动重启或关机，已连接状态（数据线插入）不会自动关机。"
                },
                {
                    "id": 5,
                    "content": "部分机型在FASTBOOT模式下不插入数据线，5分钟到半小时内会自动重启或关机",
                    "correct": true,
                    "explanation": "部分机型在未连接（数据线拔出）时，5 分钟到半小时内才会自动重启或关机，已连接状态（数据线插入）不会自动关机。"
                },
                {
                    "id": 6,
                    "content": "反复插拔数据线5次",
                    "correct": false,
                    "explanation": "插拔数据线不会造成任何影响。"
                }
            ]
        },
        {
            "id": 43,
            "content": "下列关于EDL刷机的说法，不正确的有？",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "搭载Qualcomm或MTK处理器的手机可以使用EDL刷机",
                    "correct": true,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。联发科（MediaTek, MTK）平台的机器需使用 MediaTek Preloader。"
                },
                {
                    "id": 2,
                    "content": "搭载Qualcomm手机不可以使用EDL刷机",
                    "correct": true,
                    "explanation": "高通（Qualcomm）平台的手机可以通过官方售后使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。"
                },
                {
                    "id": 3,
                    "content": "EDL刷机仅适用于小米14系列和Redmi K70系列之前发布的手机",
                    "correct": true,
                    "explanation": "Xiaomi/Redmi 所有搭载高通（Qualcomm）处理器的手机均可使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。自小米 8 后，小米公司不再允许用户自行使用 EDL 刷机，用户需前往官方售后服务网点才能使用 EDL 刷机。"
                },
                {
                    "id": 4,
                    "content": "Redmi所有手机均可使用EDL模式",
                    "correct": true,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。"
                },
                {
                    "id": 5,
                    "content": "EDL刷机无需进入Fastboot模式后使用",
                    "correct": true,
                    "explanation": "Qualcomm Emergency Download（EDL, 9008 模式）刷机更为底层，能够在无法进入 fastboot 时救砖。"
                },
                {
                    "id": 6,
                    "content": "EDL刷机需要进入Fastboot模式后使用",
                    "correct": true,
                    "explanation": "Qualcomm Emergency Download（EDL, 9008 模式）刷机更为底层，能够在无法进入 fastboot 时救砖。"
                }
            ]
        },
        {
            "id": 44,
            "content": "以下关于9008模式的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "9008模式仅限手机可正常进入系统时才可使用",
                    "correct": false,
                    "explanation": "Qualcomm Emergency Download（EDL 或 9008）模式刷机更为底层，通常用于在无法进入系统时救砖。"
                },
                {
                    "id": 2,
                    "content": "9008模式下的刷机会比fastboot模式下的刷机更加彻底",
                    "correct": true,
                    "explanation": "Qualcomm Emergency Download（EDL 或 9008）模式刷机更为底层，能够写入一些在 fastboot 模式下无法写入的分区或数据。"
                },
                {
                    "id": 3,
                    "content": "9008模式下的刷机不如fastboot模式下的刷机更加彻底",
                    "correct": false,
                    "explanation": "Qualcomm Emergency Download（EDL 或 9008）模式刷机更为底层，能够写入一些在 fastboot 模式下无法写入的分区或数据。"
                },
                {
                    "id": 4,
                    "content": "手机必须搭载高通处理器或联发科处理器才能使用9008模式刷机",
                    "correct": false,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 9008 模式刷机救砖。联发科（MediaTek, MTK）平台的机器需使用 MediaTek Preloader。"
                },
                {
                    "id": 5,
                    "content": "手机必须搭载高通处理器才能使用9008模式刷机",
                    "correct": true,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 9008 模式刷机救砖。"
                },
                {
                    "id": 6,
                    "content": "小米仅部分手机可使用9008模式",
                    "correct": true,
                    "explanation": "Xiaomi/Redmi 仅搭载高通（Qualcomm）处理器的手机才可使用 Qualcomm Emergency Download（EDL 或 9008）模式刷机。自小米 8 后，小米公司不再允许用户自行使用 EDL 刷机，用户需前往官方售后服务网点才能使用 EDL 刷机。"
                },
                {
                    "id": 7,
                    "content": "小米所有手机均可使用9008模式",
                    "correct": false,
                    "explanation": "Xiaomi/Redmi 仅搭载高通（Qualcomm）处理器的手机才可使用 Qualcomm Emergency Download（EDL 或 9008）模式刷机。自小米 8 后，小米公司不再允许用户自行使用 EDL 刷机，用户需前往官方售后服务网点才能使用 EDL 刷机。"
                },
                {
                    "id": 8,
                    "content": "并非所有小米手机均可使用9008模式",
                    "correct": true,
                    "explanation": "Xiaomi/Redmi 仅搭载高通（Qualcomm）处理器的手机才可使用 Qualcomm Emergency Download（EDL 或 9008）模式刷机。自小米 8 后，小米公司不再允许用户自行使用 EDL 刷机，用户需前往官方售后服务网点才能使用 EDL 刷机。"
                },
                {
                    "id": 9,
                    "content": "刷机过程中如果变砖，可以通过9008模式刷机救回MTK平台的机器 ",
                    "correct": false,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。联发科（MediaTek, MTK）平台的机器需使用 MediaTek Preloader。"
                },
                {
                    "id": 10,
                    "content": "刷机过程中如果变砖，不可以通过9008的模式刷机救回MTK平台的机器",
                    "correct": true,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。联发科（MediaTek, MTK）平台的机器需使用 MediaTek Preloader。"
                },
                {
                    "id": 11,
                    "content": "刷机过程中如果变砖，可以通过9008的模式刷机救回非MTK平台的机器",
                    "correct": false,
                    "explanation": "仅高通（Qualcomm）平台的手机可以通过官方售后使用 Qualcomm Emergency Download（EDL, 9008 模式）刷机。联发科（MediaTek, MTK）平台的机器需使用 MediaTek Preloader。Xiaomi 澎湃松果（Surge）平台的设备亦无法使用 9008 模式救砖。"
                }
            ]
        },
        {
            "id": 45,
            "content": "以下适用于View类的onDraw()方法有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "如果需要自定义绘制视图，则必须重写onDraw方法",
                    "correct": true,
                    "explanation": "根据 Android 开发者文档，onDraw 方法的介绍为 Implement this to do your drawing。自定义绘制时需要重写（Override）实现此方法。"
                },
                {
                    "id": 2,
                    "content": "如果需要自定义绘制视图，不必重写onDraw方法",
                    "correct": false,
                    "explanation": "根据 Android 开发者文档，onDraw 方法的介绍为 Implement this to do your drawing。自定义绘制时需要重写（Override）实现此方法。"
                },
                {
                    "id": 3,
                    "content": "它接收两个参数：Canvas和View",
                    "correct": false,
                    "explanation": "根据 Android 开发者文档，onDraw 方法签名为 protected void android.view.View.onDraw (android.graphics.Canvas canvas)。只有一个 android.graphics.Canvas 类型的参数。"
                },
                {
                    "id": 4,
                    "content": "它接收一个Canvas类型的参数",
                    "correct": true,
                    "explanation": "根据 Android 开发者文档，onDraw 方法签名为 protected void android.view.View.onDraw (android.graphics.Canvas canvas)。只有一个 android.graphics.Canvas 类型的参数。"
                },
                {
                    "id": 5,
                    "content": "它使用Canvas参数来绘制包含它的Activity的边缘",
                    "correct": false,
                    "explanation": "根据 Android 开发者文档，Canvas 参数的介绍为 the canvas on which the background will be drawn。它用于绘制背景，而不是 Activity 边缘。"
                }
            ]
        },
        {
            "id": 46,
            "content": "关于AndroidManifest.xml中的manifest标签，以下说法正确的是",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "它声明应用程序特定的属性",
                    "correct": true,
                    "explanation": "manifest 标签中可以声明应用包名（Package Name）、版本号（Version Name）、内部版本号（Version Code）等特定属性。"
                },
                {
                    "id": 2,
                    "content": "它可以被嵌套在application的标签内",
                    "correct": false,
                    "explanation": "manifest 标签必须声明在 AndroidManifest.xml 最外层，不能嵌套到 application 标签内。"
                },
                {
                    "id": 3,
                    "content": "它声明组件特定属性",
                    "correct": false,
                    "explanation": "组件特定属性在 application 标签内子标签中声明。"
                },
                {
                    "id": 4,
                    "content": "这是AndroidManifest.xml中必须标签",
                    "correct": true,
                    "explanation": "manifest 标签必须在 AndroidManifest.xml 最外层存在。"
                }
            ]
        },
        {
            "id": 47,
            "content": "下列关于JVM垃圾回收机制的说法不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "Serial Collector回收速度慢",
                    "correct": false,
                    "explanation": "串行垃圾回收器（Serial Collector）占用低，但回收速度慢。"
                },
                {
                    "id": 2,
                    "content": "Serial Collector回收速度快",
                    "correct": true,
                    "explanation": "串行垃圾回收器（Serial Collector）占用低，但回收速度慢。"
                },
                {
                    "id": 3,
                    "content": "Serial Collector适合于内存有限的情况",
                    "correct": true,
                    "explanation": "串行垃圾回收器（Serial Collector）是额外内存消耗最小的，适合配置较低的机器、或内存有限的情况。"
                },
                {
                    "id": 4,
                    "content": "Concurrent Mark Sweep Collector在Old区回收暂停时间长",
                    "correct": true,
                    "explanation": "并发标记清除垃圾回收器（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。"
                },
                {
                    "id": 5,
                    "content": "Parallel Collector效率低",
                    "correct": true,
                    "explanation": "并行垃圾回收器（Parallel Collector）具有高吞吐量的优势，能够高效利用 CPU。"
                },
                {
                    "id": 6,
                    "content": "Parallel Collector效率高",
                    "correct": true,
                    "explanation": "并行垃圾回收器（Parallel Collector）具有高吞吐量的优势，能够高效利用 CPU。"
                },
                {
                    "id": 7,
                    "content": "Parallel Collector适合于内存有限的情况",
                    "correct": true,
                    "explanation": "并行垃圾回收器（Parallel Collector）占用内存较多，优势是高吞吐量，能够高效利用 CPU。"
                },
                {
                    "id": 8,
                    "content": "G1垃圾回收器作为分代收集器，区分年轻代和老年代",
                    "correct": true,
                    "explanation": "G1（Garbage First）垃圾回收器面向堆内存任何部分来组成回收集进行回收，衡量标准不再是它属于哪个分代。"
                },
                {
                    "id": 9,
                    "content": "G1垃圾回收器设计原则是收集尽可能少的垃圾",
                    "correct": true,
                    "explanation": "G1（Garbage First）垃圾回收器面向堆内存任何部分来组成回收集进行回收，衡量标准是哪块内存中存放的垃圾数量最多，回收收益最大。"
                },
                {
                    "id": 10,
                    "content": "G1垃圾回收器的设计原则是收集尽可能多的垃圾",
                    "correct": true,
                    "explanation": "G1（Garbage First）垃圾回收器面向堆内存任何部分来组成回收集进行回收，衡量标准是哪块内存中存放的垃圾数量最多，回收收益最大。"
                },
                {
                    "id": 11,
                    "content": "G1垃圾回收器将堆内存划分为多个大小不等的Region",
                    "correct": true,
                    "explanation": "G1（Garbage First）垃圾回收器将连续的 Java 堆划分为多个大小相等的独立区域（Region）。"
                },
                {
                    "id": 12,
                    "content": "G1垃圾回收器将堆内存划分多个大小相等的Region",
                    "correct": true,
                    "explanation": "G1（Garbage First）垃圾回收器将连续的 Java 堆划分为多个大小相等的独立区域（Region）。"
                },
                {
                    "id": 13,
                    "content": "G1垃圾回收器采用的是分布式垃圾收集器",
                    "correct": false,
                    "explanation": "G1（Garbage First）垃圾回收器针对于拥有多核处理器和大内存的机器，具有分布式的特性。"
                },
                {
                    "id": 14,
                    "content": "G1垃圾回收器采用的是区域化、分布式的垃圾收集器",
                    "correct": false,
                    "explanation": "G1（Garbage First）垃圾回收器针对于拥有多核处理器和大内存的机器，具有区域化、分布式的特性。"
                }
            ]
        },
        {
            "id": 48,
            "content": "下列关于Android安全机制的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "Android的安全机制包括进程沙箱隔离机制、应用程序签名机制、访问控制机制、事件分发机制等",
                    "correct": true,
                    "explanation": "事件分发机制不属于 Android 的安全机制。"
                },
                {
                    "id": 2,
                    "content": "Android的安全机制的包括进程沙箱隔离机制、应用程序签名机制、访问控制机制等",
                    "correct": false,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 3,
                    "content": "Android的安全机制的包括进程沙箱隔离机制、访问控制机制、应用程序签名机制等",
                    "correct": false,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 4,
                    "content": "Android的安全机制的包括进程沙箱隔离机制、数据保护机制、应用程序签名机制等",
                    "correct": false,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 5,
                    "content": "Android安全机制包括dm-verity，avb，bootloader等",
                    "correct": true,
                    "explanation": "根据 Android 文档，device-mapper-verity（dm-verity）用于校验块存储设备的完整性，启动时验证（Android Verified Boot, AVB）用于确保所有已执行代码均来自可信来源，引导加载器（BootLoader）用于监护设备状态、初始化可信执行环境 (TEE) 以及绑定其信任根。除此之外，Android 还有更多安全机制。"
                },
                {
                    "id": 6,
                    "content": "Android安全策略基于DAC+Sandbox，因此root用户不受任何限制，可执行任意操作",
                    "correct": true,
                    "explanation": "root 用户会受限于 SELinux 规则，在执行一些操作时仍然会被 SELinux（和/或 seccomp）机制限制，并非不受任何限制。所以在开发需要获取最高权限时，还需要将 SELinux 设置为宽容模式，仅提升到 root 用户并非最高权限。"
                },
                {
                    "id": 7,
                    "content": "Android系统使用TEE来保护极度敏感的数据，BL解锁后会导致TEE熔断",
                    "correct": false,
                    "explanation": "小米为了保护用户敏感数据，添加了 TEE 熔断机制，解锁 BootLoader 后，一些刷机行为会触发熔断机制，具体机制介绍可参考我酷安动态。其他厂商出于保护用户数据安全考量，也可能会添加熔断机制（如 Motorola）。"
                }
            ]
        },
        {
            "id": 49,
            "content": "下列关于Android应用权限的相关说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "Android 8或更高版本的设备中，用户必须授予权限，系统才能从应用商店以外的来源安装应用",
                    "correct": false,
                    "explanation": "Android 8 后，用户需要在设置中对应用单独授予「安装外部来源应用」权限（android.permission.REQUEST_INSTALL_PACKAGES）。"
                },
                {
                    "id": 2,
                    "content": "PROCESS_OUTGOING_CALLS权限允许应用程序访问通话记录",
                    "correct": true,
                    "explanation": "该权限不提供访问通话记录的授权。如需访问通话记录，请使用 READ_CALL_LOG 权限。"
                },
                {
                    "id": 3,
                    "content": "PROCESS_OUTGOING_CALLS权限应用程序监控或中止拨出呼叫",
                    "correct": false,
                    "explanation": "该权限将允许应用在电话呼出期间查看正在拨打的号码，并提供将呼叫重定向到其他号码和中断呼叫的选项。"
                },
                {
                    "id": 4,
                    "content": "PROCESS_OUTGOING_CALLS权限允许应用程序记录拨出电话",
                    "correct": false,
                    "explanation": "应用获取该权限后能够查看拨打的号码，应用获取到号码后可以将其记录。"
                },
                {
                    "id": 5,
                    "content": "PROCESS_OUTGOING_CALLS权限允许应用程序转接来电",
                    "correct": true,
                    "explanation": "该权限无法影响呼入电话的行为，无法用于转接来电。"
                }
            ]
        },
        {
            "id": 50,
            "content": "以下关于Dialog类的描述正确的是",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "可以调用setContentView()将自定义布局添加到Dialog",
                    "correct": true,
                    "explanation": "根据 Android 开发者文档，setContentView 方法的介绍为 Set the screen content from a layout resource (to an explicit view)。用于添加自定义布局。"
                },
                {
                    "id": 2,
                    "content": "Dialog具有独立于Activity的生命周期",
                    "correct": false,
                    "explanation": "在 Activity 销毁时，Dialog 也会随之销毁。"
                },
                {
                    "id": 3,
                    "content": "调用show()方法在屏幕上显示一个Dialog",
                    "correct": true,
                    "explanation": "根据 Android 开发者文档，setContentView 方法的介绍为 Start the dialog and display it on screen。用于将对话框（Dialog）显示在屏幕上。"
                },
                {
                    "id": 4,
                    "content": "Dialog没有访问拥有它的Activity的方法",
                    "correct": false,
                    "explanation": "根据 Android 开发者文档，方法 public final android.app.Activity android.app.Dialog.getOwnerActivity () 用于获取拥有 Dialog 的 Activity。"
                }
            ]
        },
        {
            "id": 51,
            "content": "以下关于versionCode和versionName的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "versionCode与用户侧显示的应用程序版本号相同",
                    "correct": false,
                    "explanation": "用户侧显示的应用程序版本号为 versionName，并非 versionCode。"
                },
                {
                    "id": 2,
                    "content": "如果同一台手机已经安装一个高versionCode的客户端版本，则无法安装同包名的低versionCode客户端",
                    "correct": true,
                    "explanation": "旧版应用通常不兼容新版的数据，为了兼容性考量，用户无法降级覆盖安装软件。"
                },
                {
                    "id": 3,
                    "content": "同一个应用程序，versionCode变动时，versionName不可以保持不变",
                    "correct": false,
                    "explanation": "versionCode 与 versionName 互不影响。"
                },
                {
                    "id": 4,
                    "content": "同一个应用程序，versionCode变动时，versionName可以保持不变",
                    "correct": true,
                    "explanation": "versionCode 与 versionName 互不影响。"
                },
                {
                    "id": 5,
                    "content": "发布新版本的应用程序时，必须从之前的versionCode开始递增",
                    "correct": true,
                    "explanation": "系统和/或应用商店通过 versionCode 来判断应用是否有更新，通常情况下，应用在发布更新时，会选择从之前的 versionCode 开始递增。"
                }
            ]
        },
        {
            "id": 52,
            "content": "Android原生提供的ContentProvider有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "应用列表",
                    "correct": false,
                    "explanation": "应用列表不属于内容提供器（Content Provider）。"
                },
                {
                    "id": 2,
                    "content": "通话记录",
                    "correct": true,
                    "explanation": "通话记录的内容提供器（Content Provider）由 com.android.dialer 提供。"
                },
                {
                    "id": 3,
                    "content": "书签",
                    "correct": false,
                    "explanation": "书签由各浏览器（或其他类型的应用程序）自己控制和/或保存，系统并不提供。"
                },
                {
                    "id": 4,
                    "content": "联系人",
                    "correct": true,
                    "explanation": "联系人的内容提供器（Content Provider）由 com.android.contacts 提供。"
                }
            ]
        },
        {
            "id": 53,
            "content": "以下关于隐式Intent的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "隐式Intent没有指定组件",
                    "correct": false,
                    "explanation": "隐式 Intent 并不指定具体的组件（Component）。相反，它指定了要执行的操作（Action），但没有指定将执行该操作（Action）的确切组件（Component）。当应用程序发送隐式 Intent 时，Android 系统会根据 Intent 的操作和数据类型来匹配合适的组件（例如 Activity、Service 或 BroadcastReceiver），然后启动匹配的组件来处理该 Intent。这种方式允许不同应用程序之间以及同一应用程序内的组件进行松散耦合的通信。"
                },
                {
                    "id": 2,
                    "content": "隐式Intent有指定的组件来运行一个确切的类",
                    "correct": true,
                    "explanation": "隐式 Intent 通过指定操作（Action）来传递意图，由系统解析 Action 并启动对应的 Activity，或弹出对话框供用户选择，并未提供确切的类。"
                },
                {
                    "id": 3,
                    "content": "隐式Intent必须包含足够的数据，允许Android系统选择最佳组件来运行",
                    "correct": false,
                    "explanation": "隐式 Intent 需要在传递意图时提供足够的数据（最少需要一个 Action），由系统解析并启动对应的 Activity，或弹出对话框供用户选择。"
                },
                {
                    "id": 4,
                    "content": "隐式Intent必须使用Bundle携带额外的数据",
                    "correct": true,
                    "explanation": "额外数据（Extra）不是必须的，传递额外数据也可以不使用 Bundle。除了 Bundle 之外，还可以使用其他方法将数据放入 Intent 中，例如直接使用 Intent 的 putExtra() 方法来添加数据，或者使用 Parcelable 对象等。Bundle 通常用于传递键值对数据的集合，但不是隐式 Intent 必须使用的唯一方式。"
                }
            ]
        },
        {
            "id": 54,
            "content": "以下有关Android系统特性的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "Android 8或更高版本的设备中，APK文件中包含运行所需全部资源，运行应用实际上是在运行APK",
                    "correct": true,
                    "explanation": "APK 的部分 Dalvik 字节码在安装时已被编译为本地机器代码，本机库在安装时也可能会解压到对应位置，实际运行的并非 APK 中的内容。应用也可能会在运行时动态下载部分资源。"
                },
                {
                    "id": 2,
                    "content": "Android 7及更低版本的设备中，同一APK文件不可以安装到所有Android系统的设备上",
                    "correct": true,
                    "explanation": "APK 文件通常是通用的，可以提取出来安装到其他受支持架构的 Android 系统设备中。"
                },
                {
                    "id": 3,
                    "content": "Android 7或更高版本的设备中，使用JIT/AOT混合编译模式",
                    "correct": false,
                    "explanation": "Android 7或更高版本的设备中，ART（Android Runtime）运行时支持 AOT（Ahead of Time）编译。在应用安装时，部分代码会被预先编译成本地机器代码，以提高应用的运行性能。JIT（Just-in-Time）编译仍然可以在运行时进行，以优化特定情况下的性能。"
                },
                {
                    "id": 4,
                    "content": "Android 7及更低版本的设备中，不使用JIT/AOT混合编译模式",
                    "correct": false,
                    "explanation": "Android 7 以下版本主要使用 JIT（Just-In-Time）编译，即在运行时将字节码翻译成机器码。而 Android 7 已引入 JIT/AOT 混合编译模式。正确的描述应为「Android 7 以下版本的设备中，不使用 JIT/AOT 混合编译模式」，该选项可能会对用户造成误导。"
                },
                {
                    "id": 5,
                    "content": "Android 7及更低版本的设备中，使用JIT/AOT混合编译模式",
                    "correct": true,
                    "explanation": "Android 7 以下版本主要使用 JIT（Just-In-Time）编译，即在运行时将字节码翻译成机器码。而 Android 7 已引入 JIT/AOT 混合编译模式。正确的描述应为「Android 7 以下版本的设备中，不使用 JIT/AOT 混合编译模式」，该选项可能会对用户造成误导。"
                },
                {
                    "id": 6,
                    "content": "HAL介于Android framework层和应用层之间，屏蔽了硬件底层的具体实现，防止AOSP受GPL污染",
                    "correct": true,
                    "explanation": "根据 Android 文档对于 AOSP 软件堆栈架构的介绍，硬件抽象层（Hardware Abstraction Layer, HAL）介于 Android 运行时（Android Runtime, ART）层与 Linux 内核（Linux Kernel）层之间，并非 Android 框架（Android Framework）层与应用（Android Apps）层之间。"
                },
                {
                    "id": 7,
                    "content": "Android系统启动时，首先启动的是zygote进程",
                    "correct": true,
                    "explanation": "Zygote 进程由 Android 运行时（Android Runtime, ART）启动。所以第一个启动的进程并不是 Zygote。"
                },
                {
                    "id": 8,
                    "content": "Android提供了Handler和Looper来满足线程间的通信，其中Looper类用来管理特定线程内对象之间的消息交换",
                    "correct": false,
                    "explanation": "在 Android 中，Looper 类用于循环处理当前线程上的消息队列，Handler 类用于发送和处理消息对象。"
                }
            ]
        },
        {
            "id": 55,
            "content": "以下关于树的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "可以将大根堆（至少含2个元素）看成是一棵二叉排序树",
                    "correct": true,
                    "explanation": "大根堆（Max Heap）的定义是：父节点的值 >= 两个子节点的值（可以只有左儿子、或只有右儿子、或没有子节点，并且不关心左右儿子谁大谁小）。而二叉排序树（Binary Search Tree，BST）的定义是：左儿子的值（如果存在） < 父节点的值 < 右儿子的值（如果存在）。二者定义存在明显区别，故该描述是错误的。"
                },
                {
                    "id": 2,
                    "content": "一棵完全二叉树第六层有8个叶结点，则结点个数最多有112个（根为第一层）",
                    "correct": true,
                    "explanation": "根据完全二叉树定义，前 $6$ 层应该是满二叉树，共有 $2^6-1=63$ 个结点。第 $6$ 层有 $8$ 个叶节点。说明有 $32-8=24$ 个结点不是叶节点，因此最多时共有 $63+24*2=111$ 个。"
                },
                {
                    "id": 3,
                    "content": "一棵完全二叉树第六层有8个叶结点，则结点个数最多有111个（根为第一层）",
                    "correct": true,
                    "explanation": "根据完全二叉树定义，前 $6$ 层应该是满二叉树，共有 $2^6-1=63$ 个结点。第 $6$ 层有 $8$ 个叶节点。说明有 $32-8=24$ 个结点不是叶节点，因此最多时共有 $63+24*2=111$ 个。"
                },
                {
                    "id": 4,
                    "content": "一棵完全二叉树第六层有8个叶结点，则该二叉树的第7层结点个数为48个（根为第一层）",
                    "correct": true,
                    "explanation": "第 7 层的节点，是第 6 层的左边 24 个的子节点（因为最右边 8 个是叶子节点），所以是 48 个。<table align=\"center\"><tr align=\"center\"><th>层</th><th>节点数</th></tr><tr align=\"center\"><td>1</td><td>1</td></tr><tr align=\"center\"><td>2</td><td>2</td></tr><tr align=\"center\"><td>3</td><td>4</td></tr><tr align=\"center\"><td>4</td><td>8</td></tr><tr align=\"center\"><td>5</td><td>16</td></tr><tr align=\"center\"><td>6</td><td>32</td></tr><tr align=\"center\"><td>7</td><td>48</td></tr></table>"
                },
                {
                    "id": 5,
                    "content": "一棵完全二叉树第六层有8个叶结点，则该二叉树的第6层结点个数为48个（根为第一层）",
                    "correct": true,
                    "explanation": "根据上表可知，该完全二叉树在第 6 层一共有 32 个节点，不是 48 个。"
                },
                {
                    "id": 6,
                    "content": "一棵完全二叉树第六层有8个叶结点，则该二叉树的第5层结点个数为32个（根为第一层）",
                    "correct": true,
                    "explanation": "根据上表可知，该完全二叉树在第 5 层一共有 16 个节点，不是 32 个。"
                },
                {
                    "id": 7,
                    "content": "若三叉树T有244个结点（叶结点的高度为1），则T的高度至少是7",
                    "correct": true,
                    "explanation": "高度一定的三叉树中节点数最多的情况是满三叉树。高度为 $5$ 的满三叉树的节点数为 $$3^0+3^1+3^2+3^3+3^4=121$$ 高度为 $6$ 的满三叉树的节点数为 $$3^0+3^1+3^2+3^3+3^4+3^5=364$$ 由于三叉树 $T$ 的节点数为 $244$，而 $121<244<364$，因此 $T$ 的高度至少为 $6$。"
                },
                {
                    "id": 8,
                    "content": "若三叉树T有244个结点（叶结点的高度为1），则T的高度至少是6",
                    "correct": true,
                    "explanation": "高度一定的三叉树中节点数最多的情况是满三叉树。高度为 $5$ 的满三叉树的节点数为 $$3^0+3^1+3^2+3^3+3^4=121$$ 高度为 $6$ 的满三叉树的节点数为 $$3^0+3^1+3^2+3^3+3^4+3^5=364$$ 由于三叉树 $T$ 的节点数为 $244$，而 $121<244<364$，因此 $T$ 的高度至少为 $6$。"
                },
                {
                    "id": 9,
                    "content": "用三叉链表作为二叉树的存储结构，当二叉树有n个结点时，有n+1个空指针",
                    "correct": true,
                    "explanation": "用三叉链表作为二叉树的存储结构，当二叉树有 $n$ 个结点时，应该有 $n+2$ 个空指针。"
                },
                {
                    "id": 10,
                    "content": "用三叉链表作为二叉树的存储结构，当二叉树有n个结点时，有n+2个空指针",
                    "correct": true,
                    "explanation": "用三叉链表作为二叉树的存储结构，当二叉树有 $n$ 个结点时，应该有 $n+2$ 个空指针。"
                },
                {
                    "id": 11,
                    "content": "某二叉树有5个叶结点，其权值分别为10、12、16、21、30，则其最小的带权路径长度是200",
                    "correct": false,
                    "explanation": "带权路径长度（Weighted Path Length, WPL）是一种用于衡量树形结构的编码长度的方法，通常应用在哈夫曼树（Huffman Tree）中。给定权值 10、12、16、21、30，要使带权路径长度最小，可构造如下哈夫曼树：<div align=\"center\"><img src = \"https://github.com/MlgmXyysd/Xiaomi-BootLoader-Questionnaire/assets/27143040/fb3ed2dc-84e0-4818-a33c-63e02814aa39\" /></div>$$WPL=(16+21+30)*2+(10+12)*3=200$$"
                }
            ]
        },
        {
            "id": 56,
            "content": "以下关于排序算法的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "对大部分元素已有序的数组进行排序时，直接插入排序比简单选择排序效率更高，其原因是直接插入排序过程中元素之间比较次数更少",
                    "correct": true,
                    "explanation": "该描述是正确的。在直接插入排序中，对已经有序的部分只需要进行少量的比较操作，而不需要进行交换操作。而在简单选择排序中，无论数组的有序程度如何，都需要对整个数组进行遍历，并进行多次比较和交换操作。"
                },
                {
                    "id": 2,
                    "content": "设数组A[]={93,946,372,9,146,151,301,485,236,327,43,892}，采用LSD基数排序将A排成升序序列，第一趟分配、收集后，元素372之前的元素是301",
                    "correct": true,
                    "explanation": "基数排序（Radix Sort）是一种稳定的排序方法。由于采用最低位优先（LSD）的基数排序，即第一趟是对个位进行分配和收集操作，因此第一趟分配和收集后的结果是 $${151,301,372,892,93,43,485,946,146,236,327,9}$$ 元素 $372$ 之前紧邻的元素是 $301$。"
                },
                {
                    "id": 3,
                    "content": "设数组A[]={93,946,372,9,146,151,301,485,236,327,43,892}，采用LSD基数排序将A排成升序序列，第一趟分配、收集后，元素372之后的元素是301",
                    "correct": true,
                    "explanation": "基数排序（Radix Sort）是一种稳定的排序方法。由于采用最低位优先（LSD）的基数排序，即第一趟是对个位进行分配和收集操作，因此第一趟分配和收集后的结果是 $${151,301,372,892,93,43,485,946,146,236,327,9}$$ 元素 $372$ 之后紧邻的元素是 $892$。"
                },
                {
                    "id": 4,
                    "content": "快速排序在最坏情况下的时间复杂度为O(n)",
                    "correct": true,
                    "explanation": "快速排序在最坏情况下，排序码共比较次数为 $\\frac{n^2}{2}$，因此最坏时间复杂度为 $O(n^2)$。"
                },
                {
                    "id": 5,
                    "content": "快速排序在最好情况下的时间复杂度为O(n^2)",
                    "correct": true,
                    "explanation": "快速排序在最好情况下，每次都能均匀地划分序列，使得每次选择的「中间元素」恰好将待排序的空间分成两个长度大致相同的子集。因为每个子集的长度接近于原来的半数，我们只需要进行 $log_2 n$ 趟划分。在这种理想状态下，快速排序的时间复杂度是最优的，即 $O(nlog_2 n)$。"
                }
            ]
        },
        {
            "id": 57,
            "content": "以下关于数组的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "若采用三元组表存储结构存储稀疏矩阵M，则除三元组外，还需要保存M中包含非零元素的行数和列数",
                    "correct": false,
                    "explanation": "三元组是（非零元素的值 $value$，所在行 $i$，所在列 $j$），无法推定矩阵 $M$ 的边界上还存在多少零元素。因此要想确定整个矩阵，还需要保存矩阵 $M$ 的行数和列数。"
                },
                {
                    "id": 2,
                    "content": "若采用三元组表存储结构存储稀疏矩阵M，则除三元组外，还需要保存矩阵M的行数和列数",
                    "correct": true,
                    "explanation": "三元组是（非零元素的值 $value$，所在行 $i$，所在列 $j$），无法推定矩阵 $M$ 的边界上还存在多少零元素。因此要想确定整个矩阵，还需要保存矩阵 $M$ 的行数和列数。"
                },
                {
                    "id": 3,
                    "content": "已知二维数组A按行优先方式存储，每个元素占用1个存储单元。若元素A[0][0]的存储地址是100, A[3][3]的存储地址是220 ,则元素A[5][5]的存储地址是300",
                    "correct": true,
                    "explanation": "按行优先方法存储，二维数组的行、列下标都是从 $0$ 开始，并且已知起始存储地址为 $100$，假设二维数组有 $n$ 行 $m$ 列。已知 $$LOC(A[3][3])=LOC(A[0][0])+(m\\times3+4-1)\\times1=220$$ 可以求出 $m=39$，则 $$LOC(A[5][5])=LOC(A[0][0])+(39\\times5+6-1)\\times1=300$$"
                },
                {
                    "id": 4,
                    "content": "已知二维数组A按行优先方式存储，每个元素占用1个存储单元。若元素A[0][0]的存储地址是100, A[3][3]的存储地址是220 ,则元素A[5][5]的存储地址是200",
                    "correct": true,
                    "explanation": "按行优先方法存储，二维数组的行、列下标都是从 $0$ 开始，并且已知起始存储地址为 $100$，假设二维数组有 $n$ 行 $m$ 列。已知 $$LOC(A[3][3])=LOC(A[0][0])+(m\\times3+4-1)\\times1=220$$ 可以求出 $m=39$，则 $$LOC(A[5][5])=LOC(A[0][0])+(39\\times5+6-1)\\times1=300$$"
                }
            ]
        },
        {
            "id": 58,
            "content": "以下关于栈和队列的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "使用数组实现的栈是线性存储结构",
                    "correct": false,
                    "explanation": "该描述是正确的，数组本身就是一种线性结构。"
                },
                {
                    "id": 2,
                    "content": "队列和栈都可以用链表来实现",
                    "correct": false,
                    "explanation": "该描述是正确的。队列是一种先进先出（FIFO）的数据结构，用链表实现队列时，新元素被添加到链表的末尾，而删除元素则发生在链表的开头；栈是一种后进先出（LIFO）的数据结构，用链表实现栈时，新元素被添加到链表的头部，而删除元素也发生在链表的头部。"
                },
                {
                    "id": 3,
                    "content": "已知初始为空的队列Q的一端仅能进行入队操作，另外一端既能进行入队操作又能进行出队操作。若Q的入队序列是1, 2, 3, 4, 5，则4, 2, 1, 3, 5是可能得到的出队序列",
                    "correct": true,
                    "explanation": "假定左端只能入队，右端既能入队又能出队。那么按照 $4,2,1,3,5$ 的顺序，则其中一个符合要求的状态序列如下（符合要求的状态序列不唯一）：<table align=\"center\"><tr align=\"center\"><th>序号</th><th>队列状态</th><th>输出</th><th>说明</th></tr><tr align=\"center\"><td>1</td><td>[]</td><td>\"\"</td><td>初始状态为空</td></tr><tr align=\"center\"><td>2</td><td>[1]</td><td>\"\"</td><td>1 从右端入队</td></tr><tr align=\"center\"><td>3</td><td>[1, 2]</td><td>\"\"</td><td>2 从右端入队</td></tr><tr align=\"center\"><td>4</td><td>[3, 1, 2]</td><td>\"\"</td><td>3 从左端入队</td></tr><tr align=\"center\"><td>5</td><td>[3, 1, 2, 4]</td><td>\"\"</td><td>4 从右端入队</td></tr><tr align=\"center\"><td>6</td><td>[3, 1, 2]</td><td>\"4\"</td><td>4 从右端出队</td></tr><tr align=\"center\"><td>7</td><td>[3, 1]</td><td>\"4, 2\"</td><td>2 从右端出队</td></tr><tr align=\"center\"><td>8</td><td>[3]</td><td>\"4, 2, 1\"</td><td>1 从右端出队</td></tr><tr align=\"center\"><td>9</td><td>[]</td><td>\"4, 2, 1, 3\"</td><td>3 从右端出队</td></tr><tr align=\"center\"><td>10</td><td>[5]</td><td>\"4, 2, 1, 3\"</td><td>5 从右端入队</td></tr><tr align=\"center\"><td>11</td><td>[]</td><td>\"4, 2, 1, 3, 5\"</td><td>5 从右端出队</td></tr></table>"
                },
                {
                    "id": 4,
                    "content": "已知初始为空的队列Q的一端仅能进行入队操作，另外一端既能进行入队操作又能进行出队操作。若Q的入队序列是1, 2, 3, 4, 5，则4, 1, 3, 2, 5是可能得到的出队序列",
                    "correct": true,
                    "explanation": "按照选项对入队和出队的操作要求，找不到一种方法满足 $4,1,3,2,5$ 的出队顺序。"
                },
                {
                    "id": 5,
                    "content": "若一个栈的入栈序列为1、2、3、...、N，输出序列的第一个元素是i，则第j个输出的元素是i-j",
                    "correct": true,
                    "explanation": "由于可以交替进行入栈、出栈操作，并不一定要将栈内元素全部出栈后才能入栈，也不一定要将序列中的元素全部进栈后才能出栈，所以无法确定第 $j$ 个输出的元素。"
                },
                {
                    "id": 6,
                    "content": "若一个栈的入栈序列为1、2、3、...、N，输出序列的第一个元素是i，则无法确定第j个输出的元素",
                    "correct": true,
                    "explanation": "由于可以交替进行入栈、出栈操作，并不一定要将栈内元素全部出栈后才能入栈，也不一定要将序列中的元素全部进栈后才能出栈，所以无法确定第 $j$ 个输出的元素。"
                },
                {
                    "id": 7,
                    "content": "若元素1、2、3、4、5、6依次进栈，允许进栈和退栈操作交替进行，但不允许连续三次进行退栈，则可能的出栈序列是4、3、5、2、6、1",
                    "correct": true,
                    "explanation": "假定左端为栈底，右端为栈顶，则出栈序列 4、3、5、2、6、1 可通过如下操作过程得到：<table align=\"center\"><tr align=\"center\"><th>序号</th><th>栈状态</th><th>输出</th><th>说明</th></tr><tr align=\"center\"><td>1</td><td>[</td><td>\"\"</td><td>初始状态为空</td></tr><tr align=\"center\"><td>2</td><td>[1</td><td>\"\"</td><td>1 入栈</td></tr><tr align=\"center\"><td>3</td><td>[1, 2</td><td>\"\"</td><td>2 入栈</td></tr><tr align=\"center\"><td>4</td><td>[1, 2, 3</td><td>\"\"</td><td>3 入栈</td></tr><tr align=\"center\"><td>5</td><td>[1, 2, 3, 4</td><td>\"\"</td><td>4 入栈</td></tr><tr align=\"center\"><td>6</td><td>[1, 2, 3</td><td>\"4\"</td><td>4 出栈</td></tr><tr align=\"center\"><td>7</td><td>[1, 2</td><td>\"4, 3\"</td><td>3 出栈</td></tr><tr align=\"center\"><td>8</td><td>[1, 2, 5</td><td>\"4, 3\"</td><td>5 入栈</td></tr><tr align=\"center\"><td>9</td><td>[1, 2</td><td>\"4, 3, 5\"</td><td>5 出栈</td></tr><tr align=\"center\"><td>10</td><td>[1</td><td>\"4, 3, 5, 2\"</td><td>2 出栈</td></tr><tr align=\"center\"><td>11</td><td>[1, 6</td><td>\"4, 3, 5, 2\"</td><td>6 入栈</td></tr><tr align=\"center\"><td>12</td><td>[1</td><td>\"4, 3, 5, 2, 6\"</td><td>6 出栈</td></tr><tr align=\"center\"><td>13</td><td>[</td><td>\"4, 3, 5, 2, 6, 1\"</td><td>1 出栈</td></tr></table>"
                },
                {
                    "id": 8,
                    "content": "若元素1、2、3、4、5、6依次进栈，允许进栈和退栈操作交替进行，但不允许连续三次进行退栈，则可能的出栈序列是1、6、5、4、3、2",
                    "correct": true,
                    "explanation": "假定左端为栈底，右端为栈顶，虽然出栈序列 1、6、5、4、3、2 可通过如下操作过程得到，但题意要求不允许连续三次退栈操作，故该序列不合法。<table align=\"center\"><tr align=\"center\"><th>序号</th><th>栈状态</th><th>输出</th><th>说明</th></tr><tr align=\"center\"><td>1</td><td>[</td><td>\"\"</td><td>初始状态为空</td></tr><tr align=\"center\"><td>2</td><td>[1</td><td>\"\"</td><td>1 入栈</td></tr><tr align=\"center\"><td>3</td><td>[</td><td>\"1\"</td><td>1 出栈</td></tr><tr align=\"center\"><td>4</td><td>[2</td><td>\"1\"</td><td>2 入栈</td></tr><tr align=\"center\"><td>5</td><td>[2, 3</td><td>\"1\"</td><td>3 入栈</td></tr><tr align=\"center\"><td>6</td><td>[2, 3, 4</td><td>\"1\"</td><td>4 入栈</td></tr><tr align=\"center\"><td>7</td><td>[2, 3, 4, 5</td><td>\"1\"</td><td>5 入栈</td></tr><tr align=\"center\"><td>8</td><td>[2, 3, 4, 5, 6</td><td>\"1\"</td><td>6 入栈</td></tr><tr align=\"center\"><td>9</td><td>[2, 3, 4, 5</td><td>\"1, 6\"</td><td>6 出栈</td></tr><tr align=\"center\"><td>10</td><td>[2, 3, 4</td><td>\"1, 6, 5\"</td><td>5 出栈</td></tr><tr align=\"center\"><td>11</td><td>[2, 3</td><td>\"1, 6, 5, 4\"</td><td>4 出栈</td></tr><tr align=\"center\"><td>12</td><td>[2</td><td>\"1, 6, 5, 4, 3\"</td><td>3 出栈</td></tr><tr align=\"center\"><td>13</td><td>[</td><td>\"1, 6, 5, 4, 3, 2\"</td><td>2 出栈</td></tr></table>"
                },
                {
                    "id": 9,
                    "content": "栈顶元素和栈底元素有可能是同一个元素",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 10,
                    "content": "栈顶元素和栈底元素不可能是同一个元素",
                    "correct": true,
                    "explanation": "栈顶元素和栈底元素有可能是同一个元素。"
                }
            ]
        },
        {
            "id": 59,
            "content": "以下关于线性表的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "对顺序存储的线性表，设其长度为n，在任何位置上插入或删除操作都是等概率的。插入一个元素时平均要移动表中的(n-1)/2个元素",
                    "correct": true,
                    "explanation": "从头到尾，一共有 n+1 个可插入的位置，需要移动的元素个数分别为 n, n-1, n-2, ..., 2, 1, 0；故平均概率为: $$(n + n-1 + n-2 + ... + 2 + 1 + 0) / (n+1) = (n + 0) * (n + 1) / 2 / (n + 1) = n/2$$"
                },
                {
                    "id": 2,
                    "content": "将长度分别为m,n的两个单链表合并为一个单链表的时间复杂度为O(m*n)",
                    "correct": true,
                    "explanation": "获得短链表尾指针需要 $O(min(m,n))$ 的时间，随后只需要将长的单链表接在后面即可。故将两个单链表合并为一个单链表的时间复杂度为 $O(min(m,n))$。"
                },
                {
                    "id": 3,
                    "content": "将长度分别为m,n的两个单链表合并为一个单链表的时间复杂度为O(m+n)",
                    "correct": true,
                    "explanation": "获得短链表尾指针需要 $O(min(m,n))$ 的时间，随后只需要将长的单链表接在后面即可。故将两个单链表合并为一个单链表的时间复杂度为 $O(min(m,n))$。"
                },
                {
                    "id": 4,
                    "content": "线性表若采用链式存储结构时，则内存中可用存储单元的地址必须连续",
                    "correct": true,
                    "explanation": "线性表采用链式存储结构时，内存中可用存储单元的地址连续或不连续都可以。"
                },
                {
                    "id": 5,
                    "content": "线性表若采用链式存储结构时，则内存中可用存储单元的地址可以连续也可以不连续",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                }
            ]
        },
        {
            "id": 60,
            "content": "以下对于计算机组成原理相关概念的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "总线位宽是指总线上同时能够传输的数据位数，通常是指数据总线的根数",
                    "correct": true,
                    "explanation": "该描述是正确的。总线上同时能够传输的数据位数的大小，通常取决于有多少根数据总线。"
                },
                {
                    "id": 2,
                    "content": "RAM指的是手机的运行内存",
                    "correct": true,
                    "explanation": "RAM 的全称为 Random-access memory，指的是运行内存。"
                },
                {
                    "id": 3,
                    "content": "RAM存储器在掉电状态下，不保留其内容",
                    "correct": true,
                    "explanation": "RAM 掉电内容会丢失，该描述是正确的。"
                },
                {
                    "id": 4,
                    "content": "ROM指的是手机的运行内存",
                    "correct": false,
                    "explanation": "ROM 的全称为 Read-only memory，指的是手机的系统固件。运行内存为 Random-access memory（RAM）。"
                },
                {
                    "id": 5,
                    "content": "计算机系统中，CPU对主存的访问方式属于随机存取",
                    "correct": true,
                    "explanation": "RAM 是随机存取的。"
                },
                {
                    "id": 6,
                    "content": "若计算机中的地址总线的宽度为24位，则最多允许直接访问主存储器的8MB物理空间",
                    "correct": false,
                    "explanation": "如果地址总线的宽度为 24 位，那么它可以产生 2 ^ 24 个不同的地址。每个地址对应内存中的 1 个字节，所以最多允许直接寻址的主存储器物理空间大小为 2 ^ 24 = 16777216 B，即 16 MB。"
                },
                {
                    "id": 7,
                    "content": "设置界地址保护和栈保护是分区分配内存管理方式的主要保护措施",
                    "correct": false,
                    "explanation": "设置界地址保护是分区分配内存管理方式的主要保护措施，但不包括栈保护。"
                },
                {
                    "id": 8,
                    "content": "设置界地址保护是分区分配内存管理方式的主要保护措施",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 9,
                    "content": "异步总线由握手信号定时，一次握手过程完成一位数据交换",
                    "correct": false,
                    "explanation": "异步定时方式也称为应答方式。在这种方式下，没有公用的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的申请后，通过接口向主设备发出“回答”信号，整个“握手”过程就是在一问一答中进行的。一次通信可以涉及多个位的数据交换。"
                },
                {
                    "id": 10,
                    "content": "突发传送总线事务可以在总线上连续传送多个数据",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 11,
                    "content": "计算机主存地址为32位，按字节编址，Cache数据区大小和主存块大小均为32KB，采用直接映射方式和回写策略，则Cache行的位数至少是274",
                    "correct": false,
                    "explanation": "本题正确答案应为 275。具体解题过程见[视频解析](https://www.acfun.cn/v/ac35280659)。"
                }
            ]
        },
        {
            "id": 61,
            "content": "以下对于计算机网络相关概念的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "子网掩码的作用是识别子网",
                    "correct": true,
                    "explanation": "子网掩码用于将 IP 地址划分为网络地址和主机地址，从而实现对网络的划分。"
                },
                {
                    "id": 2,
                    "content": "在不做子网划分的情况下，154.21.0.0/12能支持65534台主机",
                    "correct": true,
                    "explanation": "在无类别域间路由（Classless Inter-Domain Routing，CIDR）中，/12 表示前 12 位为网络标识，剩余的 32 - 12 = 20 位用于主机标识。在不考虑子网划分的情况下，主机部分有 2 ^ 20 个可用地址，减去广播和网关地址，实际可用地址数为 2 ^ 20 - 2 = 1048574，即能支持的最大主机数。"
                },
                {
                    "id": 3,
                    "content": "在不做子网划分的情况下，154.27.0.0/16能支持65534台主机",
                    "correct": true,
                    "explanation": "在无类别域间路由（Classless Inter-Domain Routing，CIDR）中，/16 表示前 16 位为网络标识，剩余的 32 - 16 = 16 位用于主机标识。在不考虑子网划分的情况下，主机部分有 2 ^ 16 个可用地址，减去广播和网关地址，实际可用地址数为 2 ^ 16 - 2 = 65534，即能支持的最大主机数。"
                },
                {
                    "id": 4,
                    "content": "若将101.200.16.0/20划分为5个子网，则可能的最小子网的可分配IP地址数是255",
                    "correct": true,
                    "explanation": "要划分出一个最小子网，应该先划分出尽可能大的子网。将该地址块按照掩码为 $0000,1000,1100,1110,1111$ 的变长子网划分，计算可得对应的 IP 地址数依次为 $2046,1022,510,254,254$。"
                },
                {
                    "id": 5,
                    "content": "若将101.200.16.0/20划分为5个子网，则可能的最小子网的可分配IP地址数是254",
                    "correct": true,
                    "explanation": "要划分出一个最小子网，应该先划分出尽可能大的子网。将该地址块按照掩码为 $0000,1000,1100,1110,1111$ 的变长子网划分，计算可得对应的 IP 地址数依次为 $2046,1022,510,254,254$。"
                },
                {
                    "id": 6,
                    "content": "若将101.200.16.0/20划分为4个子网，则可能的最小子网的可分配IP地址数是254",
                    "correct": true,
                    "explanation": "要划分出一个最小子网，应该先划分出尽可能大的子网。将该地址块按照掩码为 $0000,1000,1100,1100$ 的变长子网划分，计算可得对应的 IP 地址数依次为 $2046,1022,510,510$。"
                },
                {
                    "id": 7,
                    "content": "在计算机网络参考模型中，第N层为第N+1层提供服务",
                    "correct": true,
                    "explanation": "计算机网络参考模型通常指的是 Open Systems Interconnection（OSI）模型，每一层（N）根据当层的协议实现接口，向其上一层（N+1）提供服务。"
                },
                {
                    "id": 8,
                    "content": "网络的拓扑结构是逻辑结构，与实际设备的物理连接没有必然的关系",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 9,
                    "content": "重定向是指将网络请求从一个网址转移到其他网址",
                    "correct": true,
                    "explanation": "对于网络请求，该描述是正确的。"
                }
            ]
        },
        {
            "id": 62,
            "content": "以下对于网络数据传输的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "网络配置后不能进入Internet服务，ping 127.0.0.1是通的，ping 网关不通，原因可能是网关没有正确配置",
                    "correct": true,
                    "explanation": "该问题的原因可能是网关没有正确配置，或者存在网络连接或路由问题。"
                },
                {
                    "id": 2,
                    "content": "通信子网为资源子网提供信息传输服务",
                    "correct": true,
                    "explanation": "通信子网通常是指负责数据传输和通信的子网，而资源子网则可能包含具体的资源（如服务器、数据库等）。通信子网提供信息传输服务以连接不同的资源子网。"
                },
                {
                    "id": 3,
                    "content": "局域网的传输速率一般比广域网高，但误码率也较高",
                    "correct": false,
                    "explanation": "前半句对，但后半句不对。一般情况下，局域网覆盖的范围比广域网小，经过的中继设备也较少，故其传输速率一般比广域网高；但也正由于局域网的覆盖范围更小，需要的传输线路更短，因此受到的环境干扰就更少，故其误码率通常会比广域网更低一些。"
                },
                {
                    "id": 4,
                    "content": "数据通信中将二进制数据位传输时出错的概率称为误码率",
                    "correct": true,
                    "explanation": "一般情况下，误码率指的是：在数据传输过程中，每个二进制bit发生错误的概率，无论传输的码元是否为二进制，均应转换为二进制码元后再进行计算。计算公式为: $$errorRrate = \\frac {errorBits} {totalBits} $$"
                }
            ]
        },
        {
            "id": 63,
            "content": "下列关于数据差错校验的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "采用CRC进行差错校验，生成多项式为G(X)=X4+X+1，信息码字为10110，则计算出的CRC校验码是0010",
                    "correct": true,
                    "explanation": "根据给定的生成多项式（10011）和信息码字，计算得出的 CRC 校验码为 1111。<div align=\"center\"><img src = \"https://github.com/MlgmXyysd/Xiaomi-BootLoader-Questionnaire/assets/17919858/e2486a12-0ec6-40e9-b30a-75cba9743148\" width=\"81.6%\" /></div>"
                },
                {
                    "id": 2,
                    "content": "CRC校验在接收端发现差错后采取的措施是反馈重发",
                    "correct": false,
                    "explanation": "CRC 校验无法纠错，如发现差错只能向发送端反馈，要求其重新发送。"
                },
                {
                    "id": 3,
                    "content": "在CRC码计算中，与101101对应的多项式为x^5+x^3+x^2+1",
                    "correct": false,
                    "explanation": "CRC 码中，二进制格式的多项式生成系数从右往左的每一位都分别代表从 0 开始，指数从小到大的项，值为 1 时表示该项存在。在此系数中，一共有 6 位，从右往左分别表示 x^0 至 x^5，其中 x^1 和 x^4 对应位的值为 0。将 x^0 替换为等值 1 后将其相加，得出此多项式。"
                },
                {
                    "id": 4,
                    "content": "假设信息位是8位，用海明码来发现并纠正1位出错的情况，则校验位的位数至少为8位",
                    "correct": true,
                    "explanation": "使用海明码来校验并纠错 8 位的信息，纠错位数至少为 4 位，而不是 8 位。计算海明码的校验位数可以使用以下不等式，m 为信息位，满足不等式的 r 最小值即为校验位数: $$2^r >= m + r + 1$$"
                }
            ]
        },
        {
            "id": 64,
            "content": "下列对于计算机网络协议的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "SSL协议属于网络层协议",
                    "correct": false,
                    "explanation": "SSL（Secure Sockets Layer）协议工作在传输层，而不是网络层。传输层是OSI模型中的第四层，负责在网络中的两个节点之间提供可靠的数据传输服务。SSL协议通过在传输层上建立安全的通信通道，实现了加密和身份验证等安全功能。"
                },
                {
                    "id": 2,
                    "content": "SNMP工作在应用层",
                    "correct": true,
                    "explanation": "SNMP（Simple Network Management Protocol，简单网络管理协议）工作在应用层。它是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及Hubs等）的一种标准协议。"
                },
                {
                    "id": 3,
                    "content": "DNS工作在应用层",
                    "correct": true,
                    "explanation": "DNS（Domain Name System，域名系统）工作在应用层。它是一个负责将域名转换为IP地址的系统，用于互联网上的地址查找和邮件转发等功能。DNS是基于TCP和UDP协议的，因此它的工作过程涉及到了应用层的数据交换。"
                }
            ]
        },
        {
            "id": 65,
            "content": "下列对于计算机网络相关软硬件的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "网桥可以有选择地转发数据帧",
                    "correct": false,
                    "explanation": "网桥是数据链路层设备，可以根据 MAC 地址选择性地转发数据帧，而不是像简单的中继器一样广播全部数据。"
                },
                {
                    "id": 2,
                    "content": "网桥不可以有选择地转发数据帧",
                    "correct": true,
                    "explanation": "网桥是数据链路层设备，可以根据 MAC 地址选择性地转发数据帧，而不是像简单的中继器一样广播全部数据。"
                },
                {
                    "id": 3,
                    "content": "交换机可以实现从多个端口上接收数据，并根据数据包头部的信息将其转发到正确的目标地址",
                    "correct": false,
                    "explanation": "交换机可以从多个端口接收数据，根据数据包头部信息（通常是 MAC 地址）来决定要转发到的目标。"
                },
                {
                    "id": 4,
                    "content": "以太网二层交换机在进行数据转发时，根据STP端口表来决定目的端口",
                    "correct": true,
                    "explanation": "以太网二层交换机在进行数据转发时，是根据 MAC 端口表来决定目的端口，而不是 STP 端口表。STP 是生成树协议（Spanning Tree Protocol）的英文缩写，可应用于计算机网络中树形拓扑结构的建立，主要作用是防止网桥网络中形成环路而产生广播风暴。"
                },
                {
                    "id": 5,
                    "content": "FDDI光纤分布式数据接口使用有容错能力的双环拓扑",
                    "correct": false,
                    "explanation": "FDDI的特点之一，就是使用双环拓扑来确保网络具有容错能力，该描述是正确的。"
                },
                {
                    "id": 6,
                    "content": "中继器和网关属于物理层设备",
                    "correct": true,
                    "explanation": "前者对，而后者不对。中继器（Repeater）工作于物理层，是最简单的网络互联设备，负责在两个网络节点的物理层上按位传递信息，完成信号的复制、调整和放大功能，用于连接同一个网络的两个或多个网段，以此从而增加信号传输的距离；而网关（Gateway）工作于网络层，也被称为路由器，负责在不同的网络之间传递数据包，并根据目标 IP 地址进行转发和路由决策，可以连接多个局域网或广域网，以帮助实现跨网络的通信和互联。"
                },
                {
                    "id": 7,
                    "content": "HAProxy配置中包含的组件有frontend、daemon、listen、global等",
                    "correct": true,
                    "explanation": "daemon 不是 HAProxy 配置中所包含的组件。HAProxy 包含 global、defaults、frontend、backend、listen 共 5 个组件。"
                }
            ]
        },
        {
            "id": 66,
            "content": "下列有关计算机安全的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "特征码查杀技术可以有效检测采用加壳技术的恶意程序",
                    "correct": false,
                    "explanation": "恶意软件加壳（或加密/加固）后，常规的特征会被外壳覆盖，使特征码查杀技术失效。"
                },
                {
                    "id": 2,
                    "content": "DNS欺骗技术可分为基于DNS服务器的欺骗和基于用户计算机的欺骗",
                    "correct": true,
                    "explanation": "该描述是正确的。举例来说，DNS 缓存污染属于 DNS 服务器欺骗，而 DNS 重定向属于用户计算机本地网络欺骗。"
                },
                {
                    "id": 3,
                    "content": "DNS欺骗是攻击者冒充域名服务器的一种欺骗行为",
                    "correct": true,
                    "explanation": "DNS 欺骗是指通过篡改域名服务器（DNS）的响应，以欺骗用户或系统，使其访问错误的网站或受到攻击。"
                },
                {
                    "id": 4,
                    "content": "ACK-Flood攻击属于利用ICP协议发起的攻击",
                    "correct": false,
                    "explanation": "在 Transmission Control Protocol（TCP）协议中，Acknowledgment（ACK）是握手的一个环节，而不是 Internet Control Message Protocol（ICP）协议。ACK-Flood 攻击通过向服务器发送大量 ACK 握手包，使服务器被迫处理这些不完整的请求，可能会因此消耗大量资源。"
                },
                {
                    "id": 5,
                    "content": "ACK-Flood攻击属于利用TCP协议发起的攻击",
                    "correct": true,
                    "explanation": "在 Transmission Control Protocol（TCP）协议中，Acknowledgment（ACK）是握手的一个环节。ACK-Flood 攻击通过向服务器发送大量 ACK 握手包，使服务器被迫处理这些不完整的请求，可能会因此消耗大量资源。"
                },
                {
                    "id": 6,
                    "content": "端口扫描是通过与目标系统的TCP/IP端口连接，并查看该系统处于监听或运行状态的服务",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 7,
                    "content": "OpenVAS是一个开放式漏洞评估系统，也可以说它是一个包含着相关工具的网络扫描器，主要用来检测远程系统和应用程序中的安全漏洞",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 8,
                    "content": "蜜罐是一种在互联网上运行的计算机系统，是专门为吸引并诱骗那些试图非法闯入他人计算机系统的人而设计的",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                }
            ]
        },
        {
            "id": 67,
            "content": "以下对于访问控制的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "RBAC模型同时具有强制访问控制和自主访问控制属性",
                    "correct": true,
                    "explanation": "RBAC（基于角色的访问控制）模型通常不包括强制访问控制（MAC）属性，而是主要集中在自主访问控制（DAC）的实现上。RABC 一般会设计若干拥有不同权限的角色，并通过将每个用户分配到一个或多个角色，以此来推定每个用户能够执行的操作。作为一种更为严格的访问控制模型，强制访问控制（MAC）与 RBAC 有着较为明显的差异，主要表现为访问权限由系统管理员在系统级别设置，并且用户或进程不能够更改或绕过这些权限，以确保访问控制的严格执行。"
                },
                {
                    "id": 2,
                    "content": "认证常用的参数有口令、标识符、生物特征等，但认证不允许第三方参与验证过程",
                    "correct": true,
                    "explanation": "在认证中，常用的参数包括口令（如密码）、标识符（如用户名）、生物特征（如指纹、虹膜、声纹、面容等）等。在一些场景中，可信的第三方可能也会参与认证，如 OAuth 开放授权协议。对于安全需求较高的认证环境，可能还会采取多方认证的方式。"
                },
                {
                    "id": 3,
                    "content": "认证常用的参数有口令、标识符、生物特征等，认证允许第三方参与验证过程",
                    "correct": false,
                    "explanation": "在认证中，常用的参数包括口令（如密码）、标识符（如用户名）、生物特征（如指纹、虹膜、声纹、面容等）等。在一些场景中，可信的第三方可能也会参与认证，如 OAuth 开放授权协议。对于安全需求较高的认证环境，可能还会采取多方认证的方式。"
                }
            ]
        },
        {
            "id": 68,
            "content": "以下有关密码学的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "哈希函数是一种双向密码机制",
                    "correct": true,
                    "explanation": "哈希（Hash）是一种单向密码，不具备可逆向性，通常只能通过碰撞的方式来得出哈希原文。"
                },
                {
                    "id": 2,
                    "content": "基于MD4和MD5设计的S/Key口令是一种一次性口令生成方案，它可以对访问者的身份与设备进行综合验证，该方案可以对抗穷举攻击",
                    "correct": true,
                    "explanation": "基于 MD4、MD5 哈希函数的 S/Key 生成的一次性口令（One-Time Password，OTP）可以对抗重放攻击，但不能对抗穷举攻击。"
                },
                {
                    "id": 3,
                    "content": "SHA算法要比MD5算法更快",
                    "correct": true,
                    "explanation": "通常情况下，SHA 算法比 MD5 算法慢，但 SHA 算法更为安全。"
                },
                {
                    "id": 4,
                    "content": "MD5算法要比SHA算法更快",
                    "correct": false,
                    "explanation": "通常情况下，MD5 算法比 SHA 算法快，但 SHA 算法更为安全。"
                },
                {
                    "id": 5,
                    "content": "对称加密最大的缺点在于其密钥管理困难",
                    "correct": false,
                    "explanation": "对称性加密使用相同的密钥进行加解密。因此，密钥管理很困难，通常可以分为以下几个方面：1）分发：当密钥在传输过程中被截获，密文就有可能被非法解密；2）更新：更新密钥时，双方都需要及时获得新密钥，否则密文无法解密；3）存储：若通信双方的任何一方未能安全存储密钥，就可能导致密钥泄露，密文被非法解密。如果是多方通信，则需要通信的每一方都有极高的安全存储要求；4）数量：为了防止密钥泄露发生，通常会为多方通信的每一位生成独立的密钥，而密钥增多又会加大密钥管理的难度。"
                },
                {
                    "id": 6,
                    "content": "DES、AES、RC4都是对称加密算法",
                    "correct": false,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 7,
                    "content": "密钥为256位的AES需要16个子密钥",
                    "correct": true,
                    "explanation": "对于 AES 算法: 密钥为 128 位时（AES-128），生成 10 个子密钥; 密钥为 192 位时（AES-192），生成 12 个子密钥; 密钥为 256 位时（AES-256），生成 14 个子密钥。每个子密钥的长度都是 128 位。这些子密钥用于对数据进行轮函数的迭代。"
                },
                {
                    "id": 8,
                    "content": "Blowfish是一个128位分组及可变密钥长度的分组密码算法",
                    "correct": true,
                    "explanation": "Blowfish 的分组位数为 64 位。"
                },
                {
                    "id": 9,
                    "content": "研究密码破译的科学称为密码分析学。密码分析学中，根据密码分析者可利用的数据资源，可将攻击密码的类型分为四种，选择密文攻击适合于攻击公开密钥密码体制，特别是攻击其数字签名",
                    "correct": false,
                    "explanation": "四种攻击类型分别是：仅密文攻击（Ciphertext-Only Attack）、已知明文攻击（Known-Plaintext Attack）、选择明文攻击（Chosen-Plaintext Attack）、选择密文攻击（Chosen-Ciphertext Attack）。其中选择密文攻击主要用于分析公钥密码体制。"
                }
            ]
        },
        {
            "id": 69,
            "content": "以下有关信息安全法律法规的说法，正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "《信息安全技术—SM3密码杂凑算法》中，SM3的杂凑值长度为16字节",
                    "correct": false,
                    "explanation": "在《信息安全技术—SM3密码杂凑算法》中，SM3 的杂凑值长度是 256 Bit，即 32 Byte。"
                },
                {
                    "id": 2,
                    "content": "BS7799标准是英国标准协会制定的信息安全管理体系标准，它包括两个部分：《信息安全管理实施指南》和《信息安全管理体系规范和应用指南》。依据该标准可以组织建立、实施与保持信息安全管理体系、对组织内关键信息资产的安全态势进行动态监测",
                    "correct": false,
                    "explanation": "BS7799 注重于建立、实施、维护和改进信息安全管理体系，而没有提及动态监测安全态势的技术和方法。"
                },
                {
                    "id": 3,
                    "content": "根据《计算机软件保护条例》，著作权法保护的计算机软件是指程序及其相关文档",
                    "correct": true,
                    "explanation": "《中华人民共和国计算机软件保护条例》第二条：本条例所称计算机软件，是指计算机程序及其有关文档。"
                },
                {
                    "id": 4,
                    "content": "《中华人民共和国网络安全法》第五十八条明确规定，因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                }
            ]
        },
        {
            "id": 70,
            "content": "下列关于Java后端开发的说法中，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "在多线程开发中，对多个同步代码的同步锁，按照以一定的顺序依次获取，可以有效避免死锁发生",
                    "correct": false,
                    "explanation": "按照一定的顺序获取多个锁的预防策略通常被称为锁的顺序规定（Lock Ordering），这意味着在整个程序中规定了一定的锁获取顺序，能够有效避免死锁发生。"
                },
                {
                    "id": 2,
                    "content": "构造函数的返回类型只能是void型",
                    "correct": true,
                    "explanation": "Java 语言中构造函数与类同名，用于新建该类的实例，不写返回类型。"
                },
                {
                    "id": 3,
                    "content": "ServerSocket这个类是实现了一个服务器端的Socket，利用这个类可以监听来自网络的请求",
                    "correct": false,
                    "explanation": "在 Java 语言中，ServerSocket 类将创建一个套接字（Socket），使用该套接字可以用于监听来自网络客户端的请求。"
                },
                {
                    "id": 4,
                    "content": "删除一个视图的SQL命令是DELETE",
                    "correct": true,
                    "explanation": "SQL 数据库中用于删除视图（View）的命令通常为「DROP VIEW <视图名>」。"
                },
                {
                    "id": 5,
                    "content": "删除一个视图的SQL命令是DELETE VIEW",
                    "correct": true,
                    "explanation": "SQL 数据库中用于删除视图（View）的命令通常为「DROP VIEW <视图名>」。"
                },
                {
                    "id": 6,
                    "content": "删除一个视图的SQL命令是DROP VIEW",
                    "correct": false,
                    "explanation": "该描述是正确的，命令后面需要附上视图（View）名称。"
                }
            ]
        },
        {
            "id": 71,
            "content": "以下对于软件工程相关概念的说法，不正确的有",
            "type": "multiple",
            "options": [
                {
                    "id": 1,
                    "content": "软件测试最基础性的测试是集成测试",
                    "correct": true,
                    "explanation": "软件测试的基础性测试是单元测试（Unit Testing）。集成测试（Integration Testing）是在已经通过了单元测试的不同单元之间进行的交互和集成测试。"
                },
                {
                    "id": 2,
                    "content": "软件测试最基础性的测试是单元测试",
                    "correct": false,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 3,
                    "content": "衡量模块的独立性的两个标准是内聚和耦合",
                    "correct": false,
                    "explanation": "在软件设计中，追求高内聚和低耦合是一个重要的原则。内聚度（Cohesion）用于度量一个模块内部各个元素（如函数、方法、类等）彼此之间的关联程度；耦合度（Coupling）用于度量一个模块与其他模块之间的关联程度。"
                },
                {
                    "id": 4,
                    "content": "衡量模块的独立性的两个标准是内聚和外联",
                    "correct": true,
                    "explanation": "在软件设计中，追求高内聚和低耦合是一个重要的原则。内聚度（Cohesion）用于度量一个模块内部各个元素（如函数、方法、类等）彼此之间的关联程度；耦合度（Coupling）用于度量一个模块与其他模块之间的关联程度。"
                },
                {
                    "id": 5,
                    "content": "UML不属于面向对象开发方法",
                    "correct": false,
                    "explanation": "UML（Unified Modeling Language）是一种通用的建模语言，它被广泛应用于面向对象开发方法中，其本身并不是一种开发方法。"
                },
                {
                    "id": 6,
                    "content": "在白盒法技术测试用例的设计中，语句覆盖是必须要满足的覆盖标准",
                    "correct": true,
                    "explanation": "在白盒法（White Box Testing）技术中，语句覆盖（Statement Coverage）是最弱的覆盖标准，必须要和其他方法结合使用。任何一种覆盖方法都无法实现完全的测试。所以，在实际的测试用例设计过程中，根据需要将不同的覆盖方法组合起来使用，以实现最佳的测试用例设计。覆盖程度：路径覆盖 > 多重条件覆盖 > 判定/条件覆盖 > 条件覆盖 > 判定覆盖 > 语句覆盖。"
                }
            ]
        },
        {
            "id": 72,
            "content": "通过fastboot -r ANTI命令可以输出ANTI版本号",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "错误",
                    "correct": true,
                    "explanation": "fastboot 不存在 -r 命令开关。正确的输出小米防回滚机制（Xiaomi Anti-Rollback）版本号命令为 fastboot getvar anti。"
                },
                {
                    "id": 2,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 73,
            "content": "Bootloader锁被解开还能重新上锁",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "对于 Xiaomi/Redmi 手机，进入 fastboot 模式并执行 fastboot oem lock 命令即可回锁（重新开启 BootLoader 锁保护）。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 74,
            "content": "在正常情况下，所有非system分区的APP运行时的UID都是一样的",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": true,
                    "explanation": "Android 系统会给每个非系统应用（untrusted_app）分配不同的 UID。"
                }
            ]
        },
        {
            "id": 75,
            "content": "Android系统加密保护用户数据，Android 10或更高版本的设备使用全盘加密",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": true,
                    "explanation": "根据 Android 文档，Android 10 或更高版本不允许使用全盘加密（Full Disk Encryption, FDE），而是使用更为灵活的文件级加密（File-Based Encryption, FBE）。"
                }
            ]
        },
        {
            "id": 76,
            "content": "输入“adb logcat”后，出现“waiting for device”信息，可能是由于设备没有连接计算机",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "该信息的含义为 【等待 device 模式的设备连接】，可能出现的原因有以下几点：1）驱动未安装或出现异常，计算机无法识别设备；2）设备没有物理连接到计算机，可检查接口是否松动或数据线是否正常；3）设备不在 device 模式，或未授权计算机；4）设备没有启用「USB 调试」功能。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 77,
            "content": "在正常情况下，所有非system分区，APP运行时的UID不是完全一样的",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "Android 系统会给每个非系统应用（untrusted_app）分配不同的 UID。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 78,
            "content": "BootLoader是在Android设备启动时最先加载到RAM中的程序，它的主要作用是把系统OS拉起来并运行",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "错误",
                    "correct": true,
                    "explanation": "根据 Android 文档，引导加载器（BootLoader）负责在设备上启动内核，而不是系统。"
                },
                {
                    "id": 2,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 79,
            "content": "在没有root情况下可以安装Magisk",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "正确",
                    "correct": true,
                    "explanation": "在手机中安装 Magisk 正是为了获取 root 权限。"
                }
            ]
        },
        {
            "id": 80,
            "content": "官方提供给用户的刷机工具是MiFlash",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "除 MiFlash（及 MiFlashPro）外，其余工具均为非官方工具。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 81,
            "content": "比特率是指将模拟声音信号转换成数字声音信号后单位时间内的二进制数据量，因此比特率越大的音质就越好",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "通常情况下，音频的比特率越高，音质就越好。实际情况可能会受限于压缩算法的影响，较低的比特率也可以提供高音质音频。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 82,
            "content": "原始设备制造商简称OEM，是英文Original Equipment Manufacturer的缩写",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 83,
            "content": "inet是UNIX系统最重要的网络服务进程",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": true,
                    "explanation": "inetd（Internet Daemon）是重要的网络服务进程，但并不存在 inet 进程，它可能指的是接口或库。"
                }
            ]
        },
        {
            "id": 84,
            "content": "adb的全称是Android Debug Bridge，起到调试桥的作用",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 85,
            "content": "adb的全称是Android Debug Badge，起到调试桥的作用",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": true,
                    "explanation": "adb 的全称为 Android Debug Bridge。"
                }
            ]
        },
        {
            "id": 86,
            "content": "原始设备制造商简称OEM，是英文Original Environment Manufacturer的缩写",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": true,
                    "explanation": "原始设备制造商（OEM）的全程是 Original Equipment Manufacturer 的缩写。"
                }
            ]
        },
        {
            "id": 87,
            "content": "inetd是UNIX系统最重要的网络服务进程",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "正确",
                    "correct": true,
                    "explanation": "inetd（Internet Daemon）是重要的网络服务进程。"
                }
            ]
        },
        {
            "id": 88,
            "content": "通过流的read()方法读取数据，返回-1表示流结尾",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": true,
                    "explanation": "该描述是正确的，读取流的函数往往用返回值 -1 来表示 EOF（End of File）。"
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 89,
            "content": "通过流的read()方法读取数据，返回1表示流结尾",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "错误",
                    "correct": true,
                    "explanation": "读取流的函数往往用返回值 -1 来表示 EOF（End of File），而不是 1。"
                }
            ]
        },
        {
            "id": 90,
            "content": "算法可以没有输入，但必须要有输出",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "错误",
                    "correct": false,
                    "explanation": ""
                },
                {
                    "id": 2,
                    "content": "正确",
                    "correct": true,
                    "explanation": "该描述是正确的。"
                }
            ]
        },
        {
            "id": 91,
            "content": "算法可以没有输出，但必须要有输入",
            "type": "single",
            "options": [
                {
                    "id": 1,
                    "content": "错误",
                    "correct": true,
                    "explanation": "算法可以没有输入，但必须要有输出。"
                },
                {
                    "id": 2,
                    "content": "正确",
                    "correct": false,
                    "explanation": ""
                }
            ]
        },
        {
            "id": 92,
            "content": "请截图本页面，并上传截图",
            "type": "upload_file",
            "note": "未正确上传该页面截图或伪造截图，将视为无效答卷，无法通过审核",
            "options": []
        },
        {
            "id": 93,
            "content": "请截图本页面，并上传截图",
            "type": "upload_file",
            "note": "[截图识别码1281-4]未正确上传该页面截图或伪造截图，将视为无效答卷，无法通过审核",
            "options": []
        }
    ]
}
